---
layout: stc-base.njk
title: Beat Sheet
description: Beat sheet builder for novelists using Blake Snyder's Save the Cat method
---

<!-- Loading Screen - inline styles load immediately -->
<div id="stc-loading" style="
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 99999;
  background: linear-gradient(145deg, #F5EEE6 0%, #EDE4D8 50%, #E8DFD1 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Lora', Georgia, serif;
  color: #2C2416;
  transition: opacity 0.4s ease-out, visibility 0.4s ease-out;
">
  <!-- Quill/pen icon -->
  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#B85C38" stroke-width="1.5" style="margin-bottom: 24px; animation: pulse 2s ease-in-out infinite;">
    <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"/>
    <line x1="16" y1="8" x2="2" y2="22"/>
    <line x1="17.5" y1="15" x2="9" y2="15"/>
  </svg>

  <div style="font-size: 1.5rem; font-weight: 500; margin-bottom: 8px;">
    Every story begins somewhere
  </div>

  <div style="font-size: 0.9rem; color: #8B7D6B; font-family: 'Source Sans 3', sans-serif;">
    Loading your workspace...
  </div>

  <!-- Subtle animated dots -->
  <div style="margin-top: 24px; display: flex; gap: 6px;">
    <span style="width: 6px; height: 6px; background: #B85C38; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></span>
    <span style="width: 6px; height: 6px; background: #B85C38; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.2s infinite;"></span>
    <span style="width: 6px; height: 6px; background: #B85C38; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.4s infinite;"></span>
  </div>
</div>

<style>
  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(0.95); }
  }
  @keyframes bounce {
    0%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-8px); }
  }
  #stc-loading.loaded {
    opacity: 0;
    visibility: hidden;
  }
</style>

<div id="stc-app">
  <!-- AUTH VIEW: Sign in prompt when logged out -->
  <div id="auth-view" class="stc-view" style="display: none;">
    <div class="stc-auth__container">
      <h2 class="stc-auth__title">Welcome, Storyteller</h2>
      <p class="stc-auth__subtitle">Sign in to save your ideas and build your beat sheet.</p>
      <button id="btn-google-signin" class="button button--google">
        <svg class="google-icon" viewBox="0 0 24 24" width="20" height="20">
          <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
          <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
          <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
          <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
        </svg>
        Sign in with Google
      </button>
    </div>
  </div>

  <!-- USER BAR: Shows when logged in -->
  <div id="user-bar" class="stc-user-bar" style="display: none;">
    <span class="stc-user-bar__email" id="user-email"></span>
    <button id="btn-signout" class="button button--secondary button--small">Sign Out</button>
  </div>

  <!-- LIST VIEW: New braindump + table of existing -->
  <div id="list-view" class="stc-view" style="display: none;">
    <div class="stc-test-flow__container">
      <h2 class="stc-test-flow__title">Okay, what's your big idea?</h2>
      <p class="stc-test-flow__subtitle">Pour it all out. Stream of consciousness. Don't hold back.</p>

      <textarea
        id="braindump-input"
        class="stc-test-flow__textarea"
        placeholder="A detective who can taste lies... A world where dreams are currency... What if the moon was actually..."
      ></textarea>

      <button id="btn-save" class="button button--primary stc-test-flow__button">
        Save My Braindump
      </button>

      <div id="result-panel" class="stc-test-flow__result" style="display: none;">
        <h3>Saved to Supabase!</h3>
        <p>Your idea is safe. <a href="#" id="dive-into-new">Dive into it now ‚Üí</a></p>
      </div>

      <div id="error-panel" class="stc-test-flow__error" style="display: none;">
        <h3>Error</h3>
        <p id="error-message"></p>
      </div>

      <!-- Existing braindumps -->
      <div id="existing-panel" class="stc-test-flow__existing">
        <h3>Recent Braindumps</h3>
        <table id="braindumps-table">
          <thead>
            <tr>
              <th>Created</th>
              <th>Idea</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="braindumps-body">
            <tr><td colspan="3" class="loading">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- DIVE VIEW: Working with a specific braindump -->
  <div id="dive-view" class="stc-view" style="display: none;">
    <div class="stc-dive__container">
      <!-- Narrow content wrapper -->
      <div class="stc-narrow">
        <button id="btn-back" class="button button--secondary stc-dive__back">
        ‚Üê Back to all ideas
      </button>

      <!-- Braindump Accordion -->
      <div class="stc-braindump-accordion" id="braindump-accordion">
        <button class="stc-braindump-accordion__toggle" id="braindump-toggle">
          <div class="stc-braindump-accordion__header">
            <h2 class="stc-dive__title">Your Braindump</h2>
            <span class="stc-dive__timestamp" id="dive-timestamp"></span>
          </div>
          <span class="stc-braindump-accordion__preview" id="braindump-preview"></span>
          <svg class="stc-braindump-accordion__chevron" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </button>

        <div class="stc-braindump-accordion__body" id="braindump-body">
          <!-- Display mode -->
          <div id="dive-display" class="stc-dive__content">
            <div id="dive-content" class="stc-dive__text"></div>
            <button id="btn-edit" class="button button--secondary stc-dive__edit">
              Edit Braindump
            </button>
          </div>

          <!-- Edit mode -->
          <div id="dive-edit" class="stc-dive__content" style="display: none;">
            <textarea id="dive-textarea" class="stc-dive__textarea"></textarea>
            <div class="stc-dive__actions">
              <button id="btn-cancel-edit" class="button button--secondary">Cancel</button>
              <button id="btn-save-edit" class="button button--primary">Save Changes</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Brief: AI-extracted summary -->
      <div class="stc-brief" id="brief-section">
        <!-- Project Title -->
        <div class="stc-brief__title-row">
          <h2 class="stc-brief__title"
              id="brief-title"
              contenteditable="true"
              spellcheck="false"
              data-placeholder="Untitled Story">Untitled Story</h2>
          <button id="btn-regenerate-title" class="stc-brief__title-regen" title="Regenerate title with AI">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 4v6h-6M1 20v-6h6"/>
              <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
            </svg>
          </button>
        </div>

        <div class="stc-brief__header">
          <h3 class="stc-brief__heading">The Brief</h3>
          <span class="stc-brief__status" id="brief-status"></span>
        </div>

        <!-- Initial state: no brief yet -->
        <div class="stc-brief__empty" id="brief-empty">
          <p class="stc-brief__note">Let Claude extract the key elements from your braindump.</p>
          <button id="btn-extract-brief" class="button button--primary">Extract Brief</button>
        </div>

        <!-- Loading state -->
        <div class="stc-brief__loading-state" id="brief-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <span>Claude is reading your braindump...</span>
        </div>

        <!-- Display state: brief extracted, pending acceptance or locked -->
        <div class="stc-brief__display" id="brief-display" style="display: none;">
          <p class="stc-brief__note" id="brief-note">Based on your braindump, here's what we're working with:</p>

          <div class="stc-brief__grid">
            <div class="stc-brief__item" data-field="coreConcept">
              <div class="stc-brief__item-header">
                <h4 class="stc-brief__label">Core Concept</h4>
                <button class="stc-brief__item-edit" title="Edit">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                </button>
              </div>
              <p class="stc-brief__content" id="brief-concept"></p>
              <textarea class="stc-brief__textarea" id="brief-concept-edit" style="display: none;"></textarea>
              <div class="stc-brief__item-actions" style="display: none;">
                <button class="button button--secondary stc-brief__item-cancel">Cancel</button>
                <button class="button button--primary stc-brief__item-save">Save</button>
              </div>
            </div>

            <div class="stc-brief__item" data-field="premise">
              <div class="stc-brief__item-header">
                <h4 class="stc-brief__label">Premise</h4>
                <button class="stc-brief__item-edit" title="Edit">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                </button>
              </div>
              <p class="stc-brief__content" id="brief-premise"></p>
              <textarea class="stc-brief__textarea" id="brief-premise-edit" style="display: none;"></textarea>
              <div class="stc-brief__item-actions" style="display: none;">
                <button class="button button--secondary stc-brief__item-cancel">Cancel</button>
                <button class="button button--primary stc-brief__item-save">Save</button>
              </div>
            </div>

            <div class="stc-brief__item" data-field="worldAndTone">
              <div class="stc-brief__item-header">
                <h4 class="stc-brief__label">World & Tone</h4>
                <button class="stc-brief__item-edit" title="Edit">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                </button>
              </div>
              <p class="stc-brief__content" id="brief-world"></p>
              <textarea class="stc-brief__textarea" id="brief-worldAndTone-edit" style="display: none;"></textarea>
              <div class="stc-brief__item-actions" style="display: none;">
                <button class="button button--secondary stc-brief__item-cancel">Cancel</button>
                <button class="button button--primary stc-brief__item-save">Save</button>
              </div>
            </div>
          </div>

          <!-- Actions for pending state -->
          <div class="stc-brief__actions" id="brief-pending-actions">
            <button id="btn-reextract-brief" class="button button--secondary">Re-extract</button>
            <button id="btn-accept-brief" class="button button--primary">Accept Brief</button>
          </div>

          <!-- Locked indicator -->
          <div class="stc-brief__locked" id="brief-locked-indicator" style="display: none;">
            <span class="stc-brief__locked-icon">‚úì</span>
            <span>Brief saved</span>
            <button id="btn-unlock-brief" class="button button--small button--secondary">Unlock to edit</button>
          </div>
        </div>
      </div>

      <!-- Spine Builder: Multi-select vertebrae -->
      <div class="stc-spine">
        <h3 class="stc-spine__heading">Build Your Spine</h3>
        <p class="stc-spine__note">Select the building blocks for your story structure:</p>

        <div class="stc-spine__vertebrae" id="vertebrae-container">
          <!-- Vertebrae will be rendered by JS from config -->
        </div>

        <div class="stc-spine__actions">
          <button id="btn-save-genome" class="button button--primary">
            Apply Genome
          </button>
          <span id="genome-status" class="stc-spine__status"></span>
        </div>
      </div>

      <!-- Story Concept Section -->
      <div class="stc-concept" id="concept-section">
        <div class="stc-concept__header">
          <h3 class="stc-concept__heading">Story Concept</h3>
          <button id="btn-generate-concept" class="button button--primary" style="display: none;">
            Generate Story Concept
          </button>
        </div>

        <!-- AI Suggestions Banner (shown when cascade detects needed updates) -->
        <div class="stc-concept__suggestions" id="concept-suggestions" style="display: none;">
          <div class="stc-concept__suggestions-header">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <line x1="12" y1="8" x2="12" y2="12"/>
              <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            <span>AI detected potential updates needed</span>
            <button class="stc-concept__suggestions-close" id="btn-close-suggestions" title="Dismiss">&times;</button>
          </div>
          <div class="stc-concept__suggestions-content">
            <div class="stc-concept__suggestions-reason" id="suggestions-reason"></div>
            <div class="stc-concept__suggestions-diff">
              <div class="stc-concept__suggestions-old">
                <div class="stc-concept__suggestions-label">Current Concept (excerpt)</div>
                <div class="stc-concept__suggestions-text" id="suggestions-current"></div>
              </div>
              <div class="stc-concept__suggestions-new">
                <div class="stc-concept__suggestions-label">Suggested Changes</div>
                <textarea class="stc-concept__suggestions-textarea" id="suggestions-proposed" placeholder="Edit the suggestions here..."></textarea>
              </div>
            </div>
            <div class="stc-concept__suggestions-actions">
              <button class="button button--secondary" id="btn-suggestions-dismiss">Dismiss</button>
              <button class="button button--primary" id="btn-suggestions-apply">
                <span class="btn-text">Apply Changes</span>
                <span class="btn-loading" style="display: none;">
                  <span class="stc-concept__suggestions-spinner"></span>
                  Applying...
                </span>
              </button>
            </div>
          </div>
        </div>

        <p class="stc-concept__note" id="concept-note">Apply your genome to unlock AI-powered story concept generation.</p>

        <!-- Ready state: genome applied, ready to generate -->
        <div id="concept-ready" class="stc-concept__ready" style="display: none;">
          <p class="stc-concept__ready-label">Your Story DNA</p>
          <div id="concept-ready-genome" class="stc-concept__ready-genome"></div>
          <button id="btn-generate-concept-cta" class="button button--primary button--large stc-concept__cta">
            Generate Story Concept
          </button>
        </div>

        <div id="concept-loading" class="stc-concept__loading" style="display: none;">
          <span class="stc-concept__spinner"></span>
          <span>Claude is thinking...</span>
        </div>

        <div id="concept-result" class="stc-concept__result" style="display: none;">
          <div id="concept-genome" class="stc-concept__genome"></div>

          <div class="stc-concept__view-toggle">
            <button class="stc-concept__view-btn stc-concept__view-btn--active" data-view="sections">
              Sections
            </button>
            <button class="stc-concept__view-btn" data-view="combined">
              Combined
            </button>
          </div>

          <div id="concept-content" class="stc-concept__content"></div>

          <div id="concept-combined" class="stc-concept__combined" style="display: none;">
            <div class="stc-concept__combined-header">
              <span class="stc-concept__combined-label">Full Concept</span>
              <button class="stc-concept__copy-btn" title="Copy to clipboard">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                <span class="stc-concept__copy-text">Copy</span>
              </button>
            </div>
            <pre id="concept-combined-text" class="stc-concept__combined-text"></pre>
          </div>

          <div class="stc-concept__actions">
            <button id="btn-regenerate-concept" class="button button--secondary">
              Regenerate
            </button>
            <span id="concept-status" class="stc-concept__status"></span>
          </div>
        </div>

        <div id="concept-error" class="stc-concept__error" style="display: none;">
          <p id="concept-error-message"></p>
        </div>
      </div>
      </div><!-- /.stc-narrow -->

      <!-- Characters Section (full width) -->
      <div class="stc-characters" id="characters-section" style="display: none;">
        <div class="stc-characters__header">
          <h3 class="stc-characters__heading">Characters</h3>
        </div>

        <p class="stc-characters__coach">
          Start with your Protagonist and Antagonist. The other roles are tools, not requirements‚Äîadd them as your story needs them. Characters can share roles or shift roles as the story evolves.
        </p>

        <!-- Pyramid Layout -->
        <div class="stc-characters__pyramid">
          <!-- Tier 1: Core Roles -->
          <div class="stc-characters__tier stc-characters__tier--1">
            <div class="stc-character-slot" data-role="protagonist" id="slot-protagonist">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Protagonist</h4>
                <p class="stc-character-slot__desc">Drives the story toward the goal. The perspective we follow.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>

            <div class="stc-character-slot" data-role="antagonist" id="slot-antagonist">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Antagonist</h4>
                <p class="stc-character-slot__desc">Opposes the goal. Not necessarily evil‚Äîjust in the way.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>
          </div>

          <!-- Tier 2: Supporting Roles -->
          <div class="stc-characters__tier stc-characters__tier--2">
            <div class="stc-character-slot" data-role="mirror" id="slot-mirror">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Mirror</h4>
                <p class="stc-character-slot__desc">Reflects or challenges the protagonist's worldview. Forces growth.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>

            <div class="stc-character-slot" data-role="ally" id="slot-ally">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Ally</h4>
                <p class="stc-character-slot__desc">Supports the protagonist. Provides faith, help, or mentorship.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>

            <div class="stc-character-slot" data-role="skeptic" id="slot-skeptic">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Skeptic</h4>
                <p class="stc-character-slot__desc">Questions and doubts. Keeps the protagonist honest.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>

            <div class="stc-character-slot" data-role="wildcard" id="slot-wildcard">
              <div class="stc-character-slot__empty">
                <h4 class="stc-character-slot__role">Wildcard</h4>
                <p class="stc-character-slot__desc">Doesn't fit neatly. Comic relief, love interest, or chaos agent.</p>
                <button class="button button--secondary stc-character-slot__add">Add Character</button>
              </div>
              <div class="stc-character-slot__filled" style="display: none;"></div>
            </div>
          </div>
        </div>

        <!-- Additional Characters (not in slots) -->
        <div class="stc-characters__extra" id="characters-extra" style="display: none;">
          <h4 class="stc-characters__extra-title">Additional Characters</h4>
          <div class="stc-characters__extra-list" id="characters-extra-list"></div>
        </div>

        <!-- Add Character Without Role -->
        <div class="stc-characters__add-more">
          <button class="button button--secondary" id="btn-add-character">
            + Add Another Character
          </button>
        </div>
      </div>

      <!-- Dev Zone: Test area for UI components -->
      <div class="stc-dev-zone" id="dev-zone" style="display: none;">
        <div class="stc-dev-zone__header">
          <button class="stc-dev-zone__toggle" id="dev-zone-toggle">
            üîß Dev Zone
            <span class="stc-dev-zone__arrow">‚ñº</span>
          </button>
        </div>
        <div class="stc-dev-zone__content" id="dev-zone-content" style="display: none;">
          <h4>Entity Rendering Test</h4>
          <p class="stc-dev-zone__label">Sample text with character names (auto-populated from your characters):</p>
          <div class="stc-dev-zone__output" id="dev-entity-test">
            <em>Add characters to see entity rendering in action.</em>
          </div>

          <h4 style="margin-top: var(--spacing-lg);">UI Component Tests</h4>
          <p class="stc-dev-zone__label">Test overlay and toast notifications (auto-dismiss after 5 seconds):</p>
          <div class="stc-dev-zone__buttons" style="display: flex; gap: var(--spacing-sm); flex-wrap: wrap; margin-top: var(--spacing-sm);">
            <button type="button" class="stc-button stc-button--secondary" id="dev-test-overlay">
              Test AI Overlay
            </button>
            <button type="button" class="stc-button stc-button--secondary" id="dev-test-toast-info">
              Toast: Info
            </button>
            <button type="button" class="stc-button stc-button--secondary" id="dev-test-toast-success">
              Toast: Success
            </button>
            <button type="button" class="stc-button stc-button--secondary" id="dev-test-toast-checking">
              Toast: Checking
            </button>
          </div>
        </div>
      </div>

      <!-- Character Edit Modal -->
      <div class="stc-modal" id="character-modal" style="display: none;">
        <div class="stc-modal__backdrop"></div>
        <div class="stc-modal__content">
          <div class="stc-modal__header">
            <h3 class="stc-modal__title" id="character-modal-title">New Character</h3>
            <button class="stc-modal__close" id="character-modal-close">&times;</button>
          </div>
          <form id="character-form" class="stc-character-form">
            <input type="hidden" id="character-id" value="">
            <input type="hidden" id="character-role" value="">

            <!-- Loading overlay -->
            <div class="stc-character-form__loading" id="character-form-loading" style="display: none;">
              <div class="loading-spinner"></div>
              <span>Generating character...</span>
            </div>

            <div class="stc-character-form__field" data-field="name">
              <div class="stc-character-form__label-row">
                <label for="character-name">Name</label>
                <button type="button" class="stc-character-form__reroll" data-field="name" title="Regenerate name">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <input type="text" id="character-name" placeholder="What's their name?" required>
            </div>

            <div class="stc-character-form__field" data-field="want">
              <div class="stc-character-form__label-row">
                <label for="character-want">Want (External Goal)</label>
                <button type="button" class="stc-character-form__reroll" data-field="want" title="Regenerate want">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <textarea id="character-want" placeholder="What do they want?" rows="2"></textarea>
            </div>

            <div class="stc-character-form__field" data-field="need">
              <div class="stc-character-form__label-row">
                <label for="character-need">Need (Internal Growth)</label>
                <button type="button" class="stc-character-form__reroll" data-field="need" title="Regenerate need">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <textarea id="character-need" placeholder="What do they need to learn?" rows="2"></textarea>
            </div>

            <div class="stc-character-form__field" data-field="arc_type">
              <div class="stc-character-form__label-row">
                <label for="character-arc-type">Arc Type</label>
                <button type="button" class="stc-character-form__reroll" data-field="arc_type" title="Regenerate arc type">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <select id="character-arc-type">
                <option value="">Select arc type...</option>
                <option value="positive-change">Positive Change ‚Äì Transforms for the better</option>
                <option value="negative-change">Negative Change ‚Äì Transforms for the worse</option>
                <option value="steadfast">Steadfast ‚Äì Holds their ground</option>
              </select>
            </div>

            <div class="stc-character-form__field" data-field="arc_description">
              <div class="stc-character-form__label-row">
                <label for="character-arc-desc">Arc Description</label>
                <button type="button" class="stc-character-form__reroll" data-field="arc_description" title="Regenerate arc description">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <textarea id="character-arc-desc" placeholder="How do they change (or hold steady)?" rows="2"></textarea>
            </div>

            <div class="stc-character-form__field" data-field="connections">
              <div class="stc-character-form__label-row">
                <label for="character-connections">Connections</label>
                <button type="button" class="stc-character-form__reroll" data-field="connections" title="Regenerate connections">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <textarea id="character-connections" placeholder="How do they relate to other characters?" rows="2"></textarea>
            </div>

            <div class="stc-character-form__actions">
              <button type="button" class="button button--secondary" id="btn-character-cancel">Cancel</button>
              <button type="button" class="button button--secondary" id="btn-character-ai">
                Generate with AI
              </button>
              <button type="submit" class="button button--primary" id="btn-character-save">Save Character</button>
            </div>

            <div class="stc-character-form__delete" id="character-delete-section" style="display: none;">
              <button type="button" class="button button--danger" id="btn-character-delete">Delete Character</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Character Sheet Modal (read-only view) -->
      <div class="stc-modal" id="character-sheet-modal" style="display: none;">
        <div class="stc-modal__backdrop"></div>
        <div class="stc-modal__content stc-character-sheet">
          <div class="stc-modal__header">
            <h3 class="stc-modal__title" id="character-sheet-title">Character</h3>
            <button class="stc-modal__close" id="character-sheet-close">&times;</button>
          </div>
          <div class="stc-character-sheet__content">
            <div class="stc-character-sheet__role" id="sheet-role"></div>

            <div class="stc-character-sheet__section">
              <h4 class="stc-character-sheet__label">Want</h4>
              <p class="stc-character-sheet__value" id="sheet-want"></p>
            </div>

            <div class="stc-character-sheet__section">
              <h4 class="stc-character-sheet__label">Need</h4>
              <p class="stc-character-sheet__value" id="sheet-need"></p>
            </div>

            <div class="stc-character-sheet__section">
              <h4 class="stc-character-sheet__label">Character Arc</h4>
              <p class="stc-character-sheet__arc-type" id="sheet-arc-type"></p>
              <p class="stc-character-sheet__value" id="sheet-arc-desc"></p>
            </div>

            <div class="stc-character-sheet__section">
              <h4 class="stc-character-sheet__label">Connections</h4>
              <p class="stc-character-sheet__value" id="sheet-connections"></p>
            </div>
          </div>
          <div class="stc-character-sheet__actions">
            <button type="button" class="button button--primary" id="sheet-edit-btn">Edit Character</button>
          </div>
        </div>
      </div>

      <!-- Cascade Confirmation Modal -->
      <div class="stc-modal stc-cascade-modal" id="cascade-modal" style="display: none;">
        <div class="stc-modal__backdrop"></div>
        <div class="stc-modal__content stc-cascade-modal__content">
          <div class="stc-modal__header">
            <h3 class="stc-modal__title">Downstream Impact Detected</h3>
            <button class="stc-modal__close" id="cascade-modal-close">&times;</button>
          </div>

          <p class="stc-cascade-modal__intro" id="cascade-intro">
            Your changes may affect other parts of your story. Review the suggested updates below.
          </p>

          <div class="stc-cascade-modal__items" id="cascade-items">
            <!-- Dynamically populated -->
          </div>

          <div class="stc-cascade-modal__actions">
            <button type="button" class="button button--secondary" id="btn-cascade-skip">Skip All</button>
            <button type="button" class="button button--primary" id="btn-cascade-apply">Apply Selected</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast notifications container -->
  <div class="stc-toast-container" id="toast-container"></div>

  <!-- AI Loading Overlay -->
  <div class="stc-ai-overlay" id="ai-overlay" style="display: none;">
    <div class="stc-ai-overlay__content">
      <div class="stc-ai-overlay__icon">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M12 2v4m0 12v4m-8-10H0m24 0h-4m-2.93-6.36l-2.83 2.83m-5.66 5.66l-2.83 2.83m0-11.32l2.83 2.83m5.66 5.66l2.83 2.83"/>
        </svg>
      </div>
      <h3 class="stc-ai-overlay__title" id="ai-overlay-title">Claude is thinking...</h3>
      <p class="stc-ai-overlay__message" id="ai-overlay-message">This may take a moment</p>
      <div class="stc-ai-overlay__dots">
        <span></span><span></span><span></span>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
  import { genres, archetypes, themes, tones, stakes, humorRole, humorStyle } from '/stc/core/logic/vertebrae.js';

  // Supabase config
  const SUPABASE_URL = 'https://vfufedgmfcqwimvglvls.supabase.co';
  const SUPABASE_ANON_KEY = 'sb_publishable_vi8VVrb56M0_TAp3vo2Gow_TXzQQqCV';
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // State
  let currentUser = null;
  let currentBraindump = null;
  let currentProject = null;
  let spineSelections = {}; // Tracks selected tags per vertebra
  let pendingRoute = null; // Stores intended destination when not logged in

  // ========== URL ROUTING ==========
  // Hash-based routing: #list, #dive/[id], #spine/[id], etc.

  function parseRoute() {
    const hash = window.location.hash.slice(1); // Remove #
    if (!hash || hash === 'list') {
      return { view: 'list', id: null };
    }
    const parts = hash.split('/');
    return { view: parts[0], id: parts[1] || null };
  }

  function updateURL(view, id = null, replace = false) {
    const hash = id ? `#${view}/${id}` : `#${view}`;
    if (replace) {
      history.replaceState({ view, id }, '', hash);
    } else {
      history.pushState({ view, id }, '', hash);
    }
  }

  async function navigateToRoute(route, skipURLUpdate = false) {
    if (!currentUser) {
      // Save intended destination for after login
      pendingRoute = route;
      return;
    }

    if (!skipURLUpdate) {
      updateURL(route.view, route.id);
    }

    switch (route.view) {
      case 'dive':
        if (route.id) {
          await diveIntoBraindump(route.id, true); // true = skip URL update
        } else {
          showListView(true);
        }
        break;
      case 'list':
      default:
        showListView(true);
        break;
    }
  }

  // Handle back/forward buttons
  window.addEventListener('popstate', (event) => {
    if (currentUser) {
      const route = event.state || parseRoute();
      navigateToRoute(route, true); // Skip URL update since browser already changed it
    }
  });

  // ========== VERTEBRAE CONFIGURATION ==========
  // Built from imported objects in /apps/stc/core/logic/vertebrae.js
  // Each vertebra object has: label, description, options
  const VERTEBRAE_CONFIG = [
    { key: 'genre', ...genres, multiSelect: true },
    { key: 'archetype', ...archetypes, multiSelect: true },
    { key: 'theme', ...themes, multiSelect: true },
    { key: 'tone', ...tones, multiSelect: true },
    { key: 'stakes', ...stakes, multiSelect: true },
  ];

  // Humor modifier config (separate from main vertebrae)
  const HUMOR_CONFIG = {
    role: { key: 'humorRole', ...humorRole, multiSelect: false },
    style: { key: 'humorStyle', ...humorStyle, multiSelect: true }
  };

  // Initialize spine selections for each vertebra
  VERTEBRAE_CONFIG.forEach(v => {
    spineSelections[v.key] = [];
  });
  // Initialize humor selections
  spineSelections.humorRole = null; // Single select, so null or single value
  spineSelections.humorStyle = [];

  // DOM elements - Auth
  const authView = document.getElementById('auth-view');
  const userBar = document.getElementById('user-bar');
  const userEmail = document.getElementById('user-email');
  const btnGoogleSignin = document.getElementById('btn-google-signin');
  const btnSignout = document.getElementById('btn-signout');

  // DOM elements - List view
  const listView = document.getElementById('list-view');
  const textarea = document.getElementById('braindump-input');
  const btnSave = document.getElementById('btn-save');
  const resultPanel = document.getElementById('result-panel');
  const errorPanel = document.getElementById('error-panel');
  const diveIntoNew = document.getElementById('dive-into-new');

  // DOM elements - Dive view
  const diveView = document.getElementById('dive-view');
  const btnBack = document.getElementById('btn-back');
  const diveTimestamp = document.getElementById('dive-timestamp');
  const diveContent = document.getElementById('dive-content');
  const diveDisplay = document.getElementById('dive-display');
  const diveEdit = document.getElementById('dive-edit');
  const diveTextarea = document.getElementById('dive-textarea');
  const btnEdit = document.getElementById('btn-edit');
  const btnCancelEdit = document.getElementById('btn-cancel-edit');
  const btnSaveEdit = document.getElementById('btn-save-edit');

  // ========== AUTH FUNCTIONS ==========

  function updateAuthUI(user) {
    const wasLoggedOut = !currentUser;
    currentUser = user;

    if (user) {
      // Logged in
      authView.style.display = 'none';
      userBar.style.display = 'flex';
      userEmail.textContent = user.email;

      // Check for pending route (deep link before auth) or URL route
      const routeToNavigate = pendingRoute || parseRoute();
      pendingRoute = null; // Clear pending route

      // Navigate to the intended destination
      navigateToRoute(routeToNavigate, false);
    } else {
      // Logged out
      authView.style.display = 'block';
      userBar.style.display = 'none';
      listView.style.display = 'none';
      diveView.style.display = 'none';

      // Check if URL has a destination to save for after login
      const route = parseRoute();
      if (route.view !== 'list' || route.id) {
        pendingRoute = route;
      }
    }
  }

  async function signInWithGoogle() {
    btnGoogleSignin.disabled = true;
    btnGoogleSignin.textContent = 'Signing in...';

    try {
      // Preserve the hash in redirect URL so we return to the right place
      const redirectUrl = window.location.origin + window.location.pathname + window.location.hash;
      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: redirectUrl
        }
      });

      if (error) throw error;
      // Browser will redirect to Google, then back
    } catch (e) {
      console.error('Sign in error:', e);
      alert('Sign in failed: ' + e.message);
      btnGoogleSignin.disabled = false;
      btnGoogleSignin.innerHTML = `
        <svg class="google-icon" viewBox="0 0 24 24" width="20" height="20">
          <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
          <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
          <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
          <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
        </svg>
        Sign in with Google
      `;
    }
  }

  async function signOut() {
    btnSignout.disabled = true;
    btnSignout.textContent = 'Signing out...';

    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
    } catch (e) {
      console.error('Sign out error:', e);
      alert('Sign out failed: ' + e.message);
    } finally {
      btnSignout.disabled = false;
      btnSignout.textContent = 'Sign Out';
    }
  }

  // ========== SPINE BUILDER FUNCTIONS ==========

  // Rainbow colors for tags
  const TAG_COLORS = [
    '#B85C38', // Terracotta (original accent)
    '#6B8E6B', // Sage green
    '#8B6B8E', // Dusty purple
    '#5C7A8B', // Steel blue
    '#C4956A', // Warm tan
    '#7B8B6B', // Olive
    '#8B7355', // Brown
    '#6B7B8B', // Slate
    '#9B6B6B', // Dusty rose
    '#5C8B7A', // Teal
  ];

  // Store combobox instances for cleanup/updates
  const comboboxInstances = {};

  // ========== COMBOBOX CLASS ==========
  // Custom accessible combobox with filtering, keyboard nav, and custom styling
  class Combobox {
    constructor(container, config) {
      this.container = container;
      this.key = config.key;
      this.options = config.options;
      this.placeholder = config.placeholder || '+ Add...';
      this.multiSelect = config.multiSelect !== false;
      this.onSelect = config.onSelect || (() => {});
      this.onRemove = config.onRemove || (() => {});
      this.getSelected = config.getSelected || (() => []);
      this.disabled = false;

      this.isOpen = false;
      this.highlightedIndex = -1;
      this.filterText = '';

      this.render();
      this.attachEvents();
    }

    render() {
      this.container.innerHTML = `
        <div class="stc-combobox" data-key="${this.key}">
          <div class="stc-combobox__input-wrap">
            <input
              type="text"
              class="stc-combobox__input"
              placeholder="${this.placeholder}"
              role="combobox"
              aria-expanded="false"
              aria-haspopup="listbox"
              aria-autocomplete="list"
              autocomplete="off"
            >
            <span class="stc-combobox__arrow">‚ñæ</span>
          </div>
          <ul class="stc-combobox__dropdown" role="listbox" tabindex="-1"></ul>
        </div>
      `;

      this.combobox = this.container.querySelector('.stc-combobox');
      this.input = this.container.querySelector('.stc-combobox__input');
      this.dropdown = this.container.querySelector('.stc-combobox__dropdown');
      this.arrow = this.container.querySelector('.stc-combobox__arrow');
    }

    attachEvents() {
      // Input focus - open dropdown
      this.input.addEventListener('focus', () => {
        if (!this.disabled) this.open();
      });

      // Input blur - close after delay (allows click on dropdown)
      this.input.addEventListener('blur', (e) => {
        setTimeout(() => {
          if (!this.combobox.contains(document.activeElement)) {
            this.close();
          }
        }, 150);
      });

      // Input typing - filter options
      this.input.addEventListener('input', (e) => {
        this.filterText = e.target.value.toLowerCase();
        this.highlightedIndex = -1;
        this.renderOptions();
        if (!this.isOpen) this.open();
      });

      // Keyboard navigation
      this.input.addEventListener('keydown', (e) => {
        if (this.disabled) return;

        const visibleOptions = this.getVisibleOptions();

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (!this.isOpen) {
              this.open();
            } else {
              this.highlightedIndex = Math.min(this.highlightedIndex + 1, visibleOptions.length - 1);
              this.updateHighlight();
            }
            break;

          case 'ArrowUp':
            e.preventDefault();
            if (this.isOpen) {
              this.highlightedIndex = Math.max(this.highlightedIndex - 1, 0);
              this.updateHighlight();
            }
            break;

          case 'Enter':
            e.preventDefault();
            if (this.isOpen && this.highlightedIndex >= 0) {
              const option = visibleOptions[this.highlightedIndex];
              if (option) this.selectOption(option);
            }
            break;

          case 'Escape':
            e.preventDefault();
            this.close();
            break;

          case 'Tab':
            this.close();
            break;
        }
      });

      // Click on arrow toggles
      this.arrow.addEventListener('click', (e) => {
        e.preventDefault();
        if (this.disabled) return;
        if (this.isOpen) {
          this.close();
        } else {
          this.input.focus();
          this.open();
        }
      });

      // Click on dropdown option
      this.dropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.stc-combobox__option');
        if (item && !item.classList.contains('stc-combobox__option--disabled')) {
          const optionId = item.dataset.id;
          const option = this.options.find(o => o.id === optionId);
          if (option) this.selectOption(option);
        }
      });

      // Prevent dropdown from closing when clicking inside it
      this.dropdown.addEventListener('mousedown', (e) => {
        e.preventDefault();
      });
    }

    getVisibleOptions() {
      const selected = this.getSelected();
      return this.options.filter(opt => {
        // Filter out already selected (for multi-select)
        if (this.multiSelect && selected.includes(opt.id)) return false;
        // Filter by search text
        if (this.filterText) {
          return opt.name.toLowerCase().includes(this.filterText) ||
                 (opt.description && opt.description.toLowerCase().includes(this.filterText));
        }
        return true;
      });
    }

    renderOptions() {
      const visibleOptions = this.getVisibleOptions();

      if (visibleOptions.length === 0) {
        this.dropdown.innerHTML = `
          <li class="stc-combobox__empty">
            ${this.filterText ? 'No matches found' : 'All options selected'}
          </li>
        `;
        return;
      }

      this.dropdown.innerHTML = visibleOptions.map((opt, index) => `
        <li
          class="stc-combobox__option ${index === this.highlightedIndex ? 'stc-combobox__option--highlighted' : ''}"
          data-id="${opt.id}"
          role="option"
          aria-selected="${index === this.highlightedIndex}"
        >
          <span class="stc-combobox__option-name">${this.highlightMatch(opt.name)}</span>
          ${opt.description ? `<span class="stc-combobox__option-desc">${opt.description}</span>` : ''}
        </li>
      `).join('');
    }

    highlightMatch(text) {
      if (!this.filterText) return text;
      const regex = new RegExp(`(${this.escapeRegex(this.filterText)})`, 'gi');
      return text.replace(regex, '<mark>$1</mark>');
    }

    escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    updateHighlight() {
      const items = this.dropdown.querySelectorAll('.stc-combobox__option');
      items.forEach((item, index) => {
        item.classList.toggle('stc-combobox__option--highlighted', index === this.highlightedIndex);
        item.setAttribute('aria-selected', index === this.highlightedIndex);
      });

      // Scroll highlighted item into view
      const highlighted = this.dropdown.querySelector('.stc-combobox__option--highlighted');
      if (highlighted) {
        highlighted.scrollIntoView({ block: 'nearest' });
      }
    }

    selectOption(option) {
      this.onSelect(option.id);
      this.filterText = '';
      this.input.value = '';
      this.highlightedIndex = -1;

      if (this.multiSelect) {
        this.renderOptions();
        this.input.focus();
      } else {
        this.close();
      }
    }

    open() {
      if (this.disabled) return;
      this.isOpen = true;
      this.combobox.classList.add('stc-combobox--open');
      this.input.setAttribute('aria-expanded', 'true');
      this.renderOptions();
    }

    close() {
      this.isOpen = false;
      this.combobox.classList.remove('stc-combobox--open');
      this.input.setAttribute('aria-expanded', 'false');
      this.filterText = '';
      this.input.value = '';
      this.highlightedIndex = -1;
    }

    setDisabled(disabled) {
      this.disabled = disabled;
      this.combobox.classList.toggle('stc-combobox--disabled', disabled);
      this.input.disabled = disabled;
      if (disabled) this.close();
    }

    refresh() {
      this.renderOptions();
    }
  }

  // ========== TAG RENDERING ==========

  function getOptionName(options, id) {
    const opt = options.find(o => o.id === id);
    return opt ? opt.name : id;
  }

  // Render a single-select tag (for humor role)
  function renderSingleTag(vertebraKey, options, onRemove) {
    const container = document.getElementById(`tags-${vertebraKey}`);
    if (!container) return;

    const selectedId = spineSelections[vertebraKey];

    // Don't show tag for "none" or empty
    if (!selectedId || selectedId === 'none') {
      container.innerHTML = '';
      return;
    }

    const name = getOptionName(options, selectedId);
    const color = TAG_COLORS[0]; // Use first color for single select

    container.innerHTML = `
      <span class="stc-tag" style="background-color: ${color}">
        <span class="stc-tag__text">${name}</span>
        <button class="stc-tag__remove" data-vertebra="${vertebraKey}" data-id="${selectedId}" aria-label="Remove ${name}">√ó</button>
      </span>
    `;

    // Attach remove handler
    container.querySelector('.stc-tag__remove').addEventListener('click', () => {
      spineSelections[vertebraKey] = 'none';
      renderSingleTag(vertebraKey, options, onRemove);
      if (onRemove) onRemove();
      // Reset combobox placeholder
      if (comboboxInstances[vertebraKey]) {
        comboboxInstances[vertebraKey].input.placeholder = 'Select humor role...';
        comboboxInstances[vertebraKey].refresh();
      }
      // Update humor style state when role changes
      if (vertebraKey === 'humorRole') {
        updateHumorStyleState();
      }
    });
  }

  function renderTags(vertebraKey, options, onRemove) {
    const container = document.getElementById(`tags-${vertebraKey}`);
    if (!container) return;

    const tags = spineSelections[vertebraKey];

    if (!tags || tags.length === 0) {
      container.innerHTML = '<span class="stc-vertebra__empty">None selected</span>';
      return;
    }

    container.innerHTML = tags.map((id, index) => {
      const color = TAG_COLORS[index % TAG_COLORS.length];
      const name = getOptionName(options, id);
      return `
        <span class="stc-tag" style="background-color: ${color}">
          <span class="stc-tag__text">${name}</span>
          <button class="stc-tag__remove" data-vertebra="${vertebraKey}" data-id="${id}" aria-label="Remove ${name}">√ó</button>
        </span>
      `;
    }).join('');

    // Attach remove handlers
    container.querySelectorAll('.stc-tag__remove').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.dataset.id;
        spineSelections[vertebraKey] = spineSelections[vertebraKey].filter(v => v !== id);
        renderTags(vertebraKey, options, onRemove);
        if (onRemove) onRemove(id);
        // Refresh combobox to show the option again
        if (comboboxInstances[vertebraKey]) {
          comboboxInstances[vertebraKey].refresh();
        }
      });
    });
  }

  // ========== RENDER VERTEBRAE ==========

  function renderVertebrae() {
    const container = document.getElementById('vertebrae-container');

    // Helper to render a standard vertebra row
    const renderRow = (vertebra, extraClass = '') => `
      <div class="stc-vertebra-row ${extraClass}" data-key="${vertebra.key}">
        <div class="stc-vertebra-row__header">
          <span class="stc-vertebra-row__number">${vertebra.number || ''}</span>
          <div class="stc-vertebra-row__header-text">
            <label class="stc-vertebra-row__label">${vertebra.label}</label>
            ${vertebra.description ? `<span class="stc-vertebra-row__description">${vertebra.description}</span>` : ''}
          </div>
        </div>
        <div class="stc-vertebra-row__body">
          <div class="stc-vertebra-row__tags" id="tags-${vertebra.key}"></div>
          <div class="stc-vertebra-row__combobox" id="combobox-${vertebra.key}"></div>
        </div>
      </div>
    `;

    // Build the spine from top to bottom
    const toneConfig = VERTEBRAE_CONFIG.find(v => v.key === 'tone');

    let html = '';

    // 1. GENRE
    const genreConfig = VERTEBRAE_CONFIG.find(v => v.key === 'genre');
    html += renderRow({ ...genreConfig, number: '1' });

    // 2. ARCHETYPE
    const archetypeConfig = VERTEBRAE_CONFIG.find(v => v.key === 'archetype');
    html += renderRow({ ...archetypeConfig, number: '2' });

    // 3. THEME
    const themeConfig = VERTEBRAE_CONFIG.find(v => v.key === 'theme');
    html += renderRow({ ...themeConfig, number: '3' });

    // 4. TONE & HUMOR (combined row with three columns)
    html += `
      <div class="stc-vertebra-row stc-vertebra-row--combined" data-key="tone-humor">
        <div class="stc-vertebra-row__header">
          <span class="stc-vertebra-row__number">4</span>
          <div class="stc-vertebra-row__header-text">
            <label class="stc-vertebra-row__label">Tone & Humor</label>
            <span class="stc-vertebra-row__description">How does it feel, and how much does humor carry?</span>
          </div>
        </div>
        <div class="stc-vertebra-row__body stc-vertebra-row__body--three-col">
          <!-- Tone (left) -->
          <div class="stc-vertebra-col" data-key="tone">
            <label class="stc-vertebra-col__label">${toneConfig.label}</label>
            <span class="stc-vertebra-col__description">${toneConfig.description}</span>
            <div class="stc-vertebra-col__tags" id="tags-tone"></div>
            <div class="stc-vertebra-col__combobox" id="combobox-tone"></div>
          </div>
          <!-- Humor Role (center) -->
          <div class="stc-vertebra-col stc-vertebra-col--humor-role" data-key="humorRole" id="humorRole-container">
            <label class="stc-vertebra-col__label">${HUMOR_CONFIG.role.label}</label>
            <span class="stc-vertebra-col__description">${HUMOR_CONFIG.role.description}</span>
            <div class="stc-vertebra-col__tags" id="tags-humorRole"></div>
            <div class="stc-vertebra-col__combobox" id="combobox-humorRole"></div>
          </div>
          <!-- Humor Style (right) -->
          <div class="stc-vertebra-col stc-vertebra-col--humor-style" data-key="humorStyle" id="humorStyle-container">
            <label class="stc-vertebra-col__label">${HUMOR_CONFIG.style.label}</label>
            <span class="stc-vertebra-col__description">${HUMOR_CONFIG.style.description}</span>
            <div class="stc-vertebra-col__tags" id="tags-humorStyle"></div>
            <div class="stc-vertebra-col__combobox" id="combobox-humorStyle"></div>
          </div>
        </div>
      </div>
    `;

    // 5. STAKES
    const stakesConfig = VERTEBRAE_CONFIG.find(v => v.key === 'stakes');
    html += renderRow({ ...stakesConfig, number: '5' });

    container.innerHTML = html;

    // Initialize comboboxes for main vertebrae
    ['genre', 'archetype', 'theme', 'stakes'].forEach(key => {
      const config = VERTEBRAE_CONFIG.find(v => v.key === key);
      const comboContainer = document.getElementById(`combobox-${key}`);

      comboboxInstances[key] = new Combobox(comboContainer, {
        key: key,
        options: config.options,
        placeholder: `+ Add ${config.label.toLowerCase()}...`,
        multiSelect: true,
        getSelected: () => spineSelections[key],
        onSelect: (id) => {
          if (!spineSelections[key].includes(id)) {
            spineSelections[key].push(id);
            renderTags(key, config.options);
          }
        }
      });

      // Initial tag render
      renderTags(key, config.options);
    });

    // Tone combobox
    const toneComboContainer = document.getElementById('combobox-tone');
    comboboxInstances.tone = new Combobox(toneComboContainer, {
      key: 'tone',
      options: toneConfig.options,
      placeholder: '+ Add tone...',
      multiSelect: true,
      getSelected: () => spineSelections.tone,
      onSelect: (id) => {
        if (!spineSelections.tone.includes(id)) {
          spineSelections.tone.push(id);
          renderTags('tone', toneConfig.options);
        }
      }
    });
    renderTags('tone', toneConfig.options);

    // Humor Role combobox (single-select behavior, but shows as tag)
    const humorRoleContainer = document.getElementById('combobox-humorRole');
    comboboxInstances.humorRole = new Combobox(humorRoleContainer, {
      key: 'humorRole',
      options: HUMOR_CONFIG.role.options,
      placeholder: 'Select humor role...',
      multiSelect: false,
      getSelected: () => spineSelections.humorRole && spineSelections.humorRole !== 'none' ? [spineSelections.humorRole] : [],
      onSelect: (id) => {
        spineSelections.humorRole = id;
        renderSingleTag('humorRole', HUMOR_CONFIG.role.options);
        updateHumorStyleState();
      }
    });
    renderSingleTag('humorRole', HUMOR_CONFIG.role.options);

    // Humor Style combobox
    const humorStyleContainer = document.getElementById('combobox-humorStyle');
    comboboxInstances.humorStyle = new Combobox(humorStyleContainer, {
      key: 'humorStyle',
      options: HUMOR_CONFIG.style.options,
      placeholder: '+ Add style...',
      multiSelect: true,
      getSelected: () => spineSelections.humorStyle,
      onSelect: (id) => {
        if (!spineSelections.humorStyle.includes(id)) {
          spineSelections.humorStyle.push(id);
          renderTags('humorStyle', HUMOR_CONFIG.style.options);
        }
      }
    });
    renderTags('humorStyle', HUMOR_CONFIG.style.options);

    // Set initial humor style state
    updateHumorStyleState();
  }

  function updateHumorStyleState() {
    const styleContainer = document.getElementById('humorStyle-container');
    const isEnabled = spineSelections.humorRole && spineSelections.humorRole !== 'none';

    if (isEnabled) {
      styleContainer.classList.remove('stc-vertebra--disabled');
      if (comboboxInstances.humorStyle) {
        comboboxInstances.humorStyle.setDisabled(false);
      }
    } else {
      styleContainer.classList.add('stc-vertebra--disabled');
      if (comboboxInstances.humorStyle) {
        comboboxInstances.humorStyle.setDisabled(true);
      }
      // Clear style selections if humor is "none"
      spineSelections.humorStyle = [];
      renderTags('humorStyle', HUMOR_CONFIG.style.options);
    }
  }

  function resetSpineSelections() {
    // Reset all multi-select vertebrae
    VERTEBRAE_CONFIG.forEach(v => {
      spineSelections[v.key] = [];
      renderTags(v.key, v.options);
      if (comboboxInstances[v.key]) {
        comboboxInstances[v.key].refresh();
      }
    });

    // Reset humor role
    spineSelections.humorRole = 'none';
    renderSingleTag('humorRole', HUMOR_CONFIG.role.options);
    if (comboboxInstances.humorRole) {
      comboboxInstances.humorRole.input.placeholder = 'Select humor role...';
      comboboxInstances.humorRole.refresh();
    }

    // Reset humor style
    spineSelections.humorStyle = [];
    renderTags('humorStyle', HUMOR_CONFIG.style.options);
    if (comboboxInstances.humorStyle) {
      comboboxInstances.humorStyle.refresh();
    }

    updateHumorStyleState();
  }

  // ========== GENOME PERSISTENCE ==========

  function getGenomeData() {
    return {
      genre: spineSelections.genre || [],
      archetype: spineSelections.archetype || [],
      theme: spineSelections.theme || [],
      tone: spineSelections.tone || [],
      stakes: spineSelections.stakes || [],
      humorRole: spineSelections.humorRole || 'none',
      humorStyle: spineSelections.humorStyle || []
    };
  }

  async function saveGenome() {
    if (!currentProject) {
      showGenomeStatus('No project selected', 'error');
      return;
    }

    const btnSave = document.getElementById('btn-save-genome');
    btnSave.disabled = true;
    btnSave.textContent = 'Applying...';

    try {
      const genome = getGenomeData();

      const { error } = await supabase
        .from('projects')
        .update({ genome: genome })
        .eq('id', currentProject.id);

      if (error) throw error;

      // Check if we have an existing concept that needs cascade analysis
      const hasExistingConcept = currentSections && currentSections.length > 0;
      const hadPreviousGenome = previousGenome !== null;

      // Update local project state
      currentProject.genome = genome;

      showGenomeStatus('Genome applied!', 'success');

      // Update concept UI now that genome is saved
      updateConceptUI();

      // If we have an existing concept and had a previous genome, check for cascade impacts
      if (hasExistingConcept && hadPreviousGenome) {
        await checkGenomeCascade(previousGenome, genome);
      }

      // Update previousGenome to current for next comparison
      previousGenome = JSON.parse(JSON.stringify(genome));

    } catch (e) {
      console.error('Save genome error:', e);
      showGenomeStatus('Failed to apply: ' + e.message, 'error');
    } finally {
      btnSave.disabled = false;
      btnSave.textContent = 'Apply Genome Changes'; // After first save, always show "Changes"
    }
  }

  async function checkGenomeCascade(prevGenome, newGenome) {
    // Show loading state in concept section
    const cascadeContainer = document.getElementById('genome-cascade-suggestions');
    if (!cascadeContainer) {
      // Create cascade suggestions container if it doesn't exist
      const conceptResult = document.getElementById('concept-result');
      const cascadeDiv = document.createElement('div');
      cascadeDiv.id = 'genome-cascade-suggestions';
      cascadeDiv.className = 'stc-cascade';
      conceptResult.insertBefore(cascadeDiv, conceptResult.firstChild);
    }

    const container = document.getElementById('genome-cascade-suggestions');
    container.innerHTML = `
      <div class="stc-cascade__loading">
        <span class="stc-concept__spinner"></span>
        <span>Analyzing how genome changes affect your concept...</span>
      </div>
    `;
    container.style.display = 'block';

    try {
      const response = await fetch('/.netlify/functions/cascade-genome', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          previousGenome: prevGenome,
          newGenome: newGenome,
          allSections: currentSections,
          braindump: currentBraindump?.raw_input || ''
        })
      });

      if (!response.ok) {
        throw new Error('Cascade analysis failed');
      }

      const data = await response.json();

      if (data.affectedSections && data.affectedSections.length > 0) {
        renderCascadeSuggestions(data.summary, data.affectedSections);
      } else {
        // No changes needed
        container.innerHTML = `
          <div class="stc-cascade__success">
            <span class="stc-cascade__success-icon">‚úì</span>
            <span>${data.summary || 'Your concept aligns well with the genome changes.'}</span>
          </div>
        `;
        setTimeout(() => {
          container.style.display = 'none';
        }, 4000);
      }
    } catch (err) {
      console.error('Cascade check error:', err);
      container.innerHTML = `
        <div class="stc-cascade__error">
          Could not analyze genome impact. You may want to review your concept manually.
        </div>
      `;
      setTimeout(() => {
        container.style.display = 'none';
      }, 5000);
    }
  }

  function renderCascadeSuggestions(summary, affectedSections) {
    const container = document.getElementById('genome-cascade-suggestions');

    const sectionsHtml = affectedSections.map((affected, idx) => `
      <div class="stc-cascade__item" data-cascade-index="${idx}">
        <div class="stc-cascade__item-header">
          <strong>${affected.section}</strong>
          <span class="stc-cascade__item-reason">${affected.reason}</span>
        </div>
        <div class="stc-cascade__item-suggestion">
          <div class="stc-cascade__item-label">Suggested revision:</div>
          <div class="stc-cascade__item-content">${formatSectionContent(affected.suggestedFix)}</div>
        </div>
        <div class="stc-cascade__item-actions">
          <button class="button button--secondary stc-cascade__ignore" data-section="${affected.section}">Ignore</button>
          <button class="button button--primary stc-cascade__apply" data-section="${affected.section}" data-fix="${encodeURIComponent(affected.suggestedFix)}">Apply Change</button>
        </div>
      </div>
    `).join('');

    container.innerHTML = `
      <div class="stc-cascade__header">
        <span class="stc-cascade__icon">‚ö†Ô∏è</span>
        <span class="stc-cascade__title">Genome changes may affect your concept</span>
      </div>
      <p class="stc-cascade__summary">${summary}</p>
      <div class="stc-cascade__list">${sectionsHtml}</div>
      <div class="stc-cascade__bulk-actions">
        <button class="button button--secondary" id="cascade-ignore-all">Ignore All</button>
        <button class="button button--primary" id="cascade-apply-all">Apply All Changes</button>
      </div>
    `;

    // Attach event listeners
    container.querySelectorAll('.stc-cascade__apply').forEach(btn => {
      btn.addEventListener('click', () => {
        const sectionName = btn.dataset.section;
        const fix = decodeURIComponent(btn.dataset.fix);
        applyCascadeFix(sectionName, fix);
        btn.closest('.stc-cascade__item').remove();
        checkCascadeComplete();
      });
    });

    container.querySelectorAll('.stc-cascade__ignore').forEach(btn => {
      btn.addEventListener('click', () => {
        btn.closest('.stc-cascade__item').remove();
        checkCascadeComplete();
      });
    });

    document.getElementById('cascade-ignore-all')?.addEventListener('click', () => {
      container.style.display = 'none';
    });

    document.getElementById('cascade-apply-all')?.addEventListener('click', async () => {
      const items = container.querySelectorAll('.stc-cascade__item');
      for (const item of items) {
        const applyBtn = item.querySelector('.stc-cascade__apply');
        if (applyBtn) {
          const sectionName = applyBtn.dataset.section;
          const fix = decodeURIComponent(applyBtn.dataset.fix);
          await applyCascadeFix(sectionName, fix);
        }
      }
      container.style.display = 'none';
    });
  }

  async function applyCascadeFix(sectionName, newContent) {
    const sectionIndex = currentSections.findIndex(s => s.name === sectionName);
    if (sectionIndex === -1) return;

    // Update the section
    currentSections[sectionIndex].content = newContent;

    // Update the display
    const sectionEl = document.querySelector(`[data-section-index="${sectionIndex}"]`);
    if (sectionEl) {
      sectionEl.querySelector('.stc-section__display').innerHTML = formatSectionContent(newContent);
      sectionEl.querySelector('.stc-section__textarea').value = newContent;
    }

    // Update combined view
    document.getElementById('concept-combined-text').textContent = formatConceptForCopy();

    // Save to database
    await saveConceptSections();
  }

  function checkCascadeComplete() {
    const container = document.getElementById('genome-cascade-suggestions');
    const remainingItems = container.querySelectorAll('.stc-cascade__item');
    if (remainingItems.length === 0) {
      container.innerHTML = `
        <div class="stc-cascade__success">
          <span class="stc-cascade__success-icon">‚úì</span>
          <span>All suggested changes have been addressed.</span>
        </div>
      `;
      setTimeout(() => {
        container.style.display = 'none';
      }, 3000);
    }
  }

  function loadGenomeIntoUI(genome) {
    if (!genome) {
      resetSpineSelections();
      previousGenome = null;
      return;
    }

    // Store as previous genome for cascade detection
    previousGenome = JSON.parse(JSON.stringify(genome));

    // Load multi-select vertebrae
    ['genre', 'archetype', 'theme', 'tone', 'stakes'].forEach(key => {
      spineSelections[key] = genome[key] || [];
      const config = VERTEBRAE_CONFIG.find(v => v.key === key);
      if (config) {
        renderTags(key, config.options);
        if (comboboxInstances[key]) {
          comboboxInstances[key].refresh();
        }
      }
    });

    // Load humor role (single select)
    spineSelections.humorRole = genome.humorRole || 'none';
    renderSingleTag('humorRole', HUMOR_CONFIG.role.options);
    if (comboboxInstances.humorRole) {
      if (spineSelections.humorRole && spineSelections.humorRole !== 'none') {
        const selectedOpt = HUMOR_CONFIG.role.options.find(o => o.id === spineSelections.humorRole);
        if (selectedOpt) {
          comboboxInstances.humorRole.input.placeholder = 'Select humor role...';
        }
      } else {
        comboboxInstances.humorRole.input.placeholder = 'Select humor role...';
      }
      comboboxInstances.humorRole.refresh();
    }

    // Load humor style
    spineSelections.humorStyle = genome.humorStyle || [];
    renderTags('humorStyle', HUMOR_CONFIG.style.options);
    if (comboboxInstances.humorStyle) {
      comboboxInstances.humorStyle.refresh();
    }

    updateHumorStyleState();
  }

  function showGenomeStatus(message, type) {
    const status = document.getElementById('genome-status');
    status.textContent = message;
    status.className = `stc-spine__status stc-spine__status--${type}`;

    // Clear after 3 seconds
    setTimeout(() => {
      status.textContent = '';
      status.className = 'stc-spine__status';
    }, 3000);
  }

  // ========== STORY CONCEPT GENERATION ==========

  // Hydrate genome IDs with full vertebrae definitions
  function hydrateGenome(genome) {
    const findOption = (options, id) => options.find(o => o.id === id);

    return {
      genres: (genome.genre || []).map(id => findOption(genres.options, id)).filter(Boolean),
      archetypes: (genome.archetype || []).map(id => findOption(archetypes.options, id)).filter(Boolean),
      themes: (genome.theme || []).map(id => findOption(themes.options, id)).filter(Boolean),
      tones: (genome.tone || []).map(id => findOption(tones.options, id)).filter(Boolean),
      stakes: (genome.stakes || []).map(id => findOption(stakes.options, id)).filter(Boolean),
      humorRole: findOption(humorRole.options, genome.humorRole) || null,
      humorStyles: (genome.humorStyle || []).map(id => findOption(humorStyle.options, id)).filter(Boolean)
    };
  }

  async function generateStoryConcept() {
    if (!currentBraindump || !currentProject?.genome) {
      showConceptError('No braindump or genome available');
      return;
    }

    const btnGenerate = document.getElementById('btn-generate-concept');
    const btnRegenerate = document.getElementById('btn-regenerate-concept');
    const loadingEl = document.getElementById('concept-loading');
    const resultEl = document.getElementById('concept-result');
    const errorEl = document.getElementById('concept-error');
    const readyEl = document.getElementById('concept-ready');
    const noteEl = document.getElementById('concept-note');

    // Show loading state
    btnGenerate.style.display = 'none';
    btnRegenerate.style.display = 'none';
    loadingEl.style.display = 'flex';
    resultEl.style.display = 'none';
    errorEl.style.display = 'none';
    readyEl.style.display = 'none';
    noteEl.style.display = 'none';
    showAIOverlay('Generating Story Concept', 'Claude is crafting your story foundation...');

    try {
      // Hydrate genome with full definitions
      const hydratedGenome = hydrateGenome(currentProject.genome);

      // Call Netlify function
      const response = await fetch('/.netlify/functions/generate-concept', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          braindump: currentBraindump.raw_input,
          genome: hydratedGenome
        })
      });

      // Check if response is JSON (Netlify functions return JSON)
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Netlify function not available. Run "netlify dev" locally or deploy to Netlify.');
      }

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to generate concept');
      }

      if (!data.concept) {
        throw new Error('Claude returned empty concept');
      }

      // Display the concept
      displayConcept(data.concept);

      // Save to database
      await saveConcept(data.concept);

    } catch (e) {
      console.error('Generate concept error:', e);
      showConceptError(e.message);
    } finally {
      loadingEl.style.display = 'none';
      hideAIOverlay();
    }
  }

  // Store parsed sections for editing
  let currentSections = [];
  let currentConceptText = ''; // Raw concept text for combined view
  let previousGenome = null; // Store genome before changes for cascade detection

  function parseConcept(text) {
    // Parse concept text into sections by ### headers
    const sections = [];
    const sectionRegex = /^### (.+)$/gm;
    let lastIndex = 0;
    let match;

    // Skip the ## Story Concept header if present
    const cleanText = text.replace(/^## Story Concept\s*\n+/, '');

    const matches = [...cleanText.matchAll(sectionRegex)];

    matches.forEach((match, i) => {
      const name = match[1].trim();
      const startContent = match.index + match[0].length;
      const endContent = matches[i + 1]?.index || cleanText.length;
      const content = cleanText.slice(startContent, endContent).trim();

      // Create a slug from the name for data attributes
      const slug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

      sections.push({ name, slug, content });
    });

    return sections;
  }

  // === Character Entity Rendering ===

  function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function renderContentWithEntities(content, characters) {
    if (!content || !characters || !characters.length) return content;

    let rendered = content;

    // Sort by name length (longest first) to avoid partial matches
    // e.g., "Sam" shouldn't match inside "Samantha"
    const sortedChars = [...characters].sort((a, b) => b.name.length - a.name.length);

    for (const char of sortedChars) {
      if (!char.name) continue;
      // Case-insensitive match, word boundaries
      const regex = new RegExp(`\\b(${escapeRegex(char.name)})\\b`, 'gi');
      rendered = rendered.replace(regex,
        `<span class="character-token" data-character-id="${char.id}" data-character-name="${char.name}">$1</span>`
      );
    }

    return rendered;
  }

  function formatSectionContent(content) {
    // Format a section's content (bold, italic, paragraphs)
    let formatted = content
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .split('\n\n')
      .map(p => p.trim())
      .filter(p => p)
      .map(p => `<p>${p}</p>`)
      .join('\n');

    // Apply character entity rendering
    return renderContentWithEntities(formatted, currentCharacters);
  }

  function renderSection(section, index) {
    const formattedContent = formatSectionContent(section.content);

    return `
      <div class="stc-section" data-section-index="${index}" data-section-slug="${section.slug}">
        <div class="stc-section__header">
          <h4 class="stc-section__title">${section.name}</h4>
          <div class="stc-section__actions">
            <button class="stc-section__btn stc-section__btn--edit" title="Edit manually">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
            <button class="stc-section__btn stc-section__btn--refine" title="Refine with AI">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="stc-section__display">
          ${formattedContent}
        </div>

        <div class="stc-section__edit-mode" style="display: none;">
          <textarea class="stc-section__textarea">${section.content}</textarea>
          <div class="stc-section__edit-actions">
            <button class="button button--secondary stc-section__cancel-edit">Cancel</button>
            <button class="button button--primary stc-section__save-edit">Save</button>
          </div>
        </div>

        <div class="stc-section__refine-mode" style="display: none;">
          <textarea class="stc-section__direction" placeholder="What direction should Claude take? e.g., 'Make it punchier' or 'Focus more on the conspiracy angle'"></textarea>
          <div class="stc-section__refine-actions">
            <button class="button button--secondary stc-section__cancel-refine">Cancel</button>
            <button class="button button--primary stc-section__send-refine">Send to Claude</button>
          </div>
        </div>

        <div class="stc-section__suggestion" style="display: none;">
          <div class="stc-section__suggestion-label">Claude's Suggestion</div>
          <div class="stc-section__suggestion-content"></div>
          <div class="stc-section__affected" style="display: none;">
            <div class="stc-section__affected-label">‚ö†Ô∏è This change may affect other sections:</div>
            <div class="stc-section__affected-list"></div>
          </div>
          <div class="stc-section__suggestion-actions">
            <button class="button button--secondary stc-section__discard">Discard</button>
            <button class="button button--secondary stc-section__try-again">Try Again</button>
            <button class="button button--primary stc-section__keep">Keep</button>
          </div>
        </div>
      </div>
    `;
  }

  function displayConcept(conceptText) {
    const resultEl = document.getElementById('concept-result');
    const genomeEl = document.getElementById('concept-genome');
    const contentEl = document.getElementById('concept-content');
    const combinedEl = document.getElementById('concept-combined');
    const combinedTextEl = document.getElementById('concept-combined-text');
    const btnRegenerate = document.getElementById('btn-regenerate-concept');

    // Store raw concept text for combined view
    currentConceptText = conceptText;

    // Display genome DNA tags
    if (currentProject?.genome) {
      const hydrated = hydrateGenome(currentProject.genome);
      const allTags = [
        ...hydrated.genres.map(g => ({ label: g.name, category: 'genre' })),
        ...hydrated.archetypes.map(a => ({ label: a.name, category: 'archetype' })),
        ...hydrated.themes.map(t => ({ label: t.name, category: 'theme' })),
        ...hydrated.tones.map(t => ({ label: t.name, category: 'tone' })),
        ...hydrated.stakes.map(s => ({ label: s.name, category: 'stakes' })),
        ...(hydrated.humorRole && hydrated.humorRole.id !== 'none'
          ? [{ label: hydrated.humorRole.name, category: 'humor' }]
          : []),
        ...hydrated.humorStyles.map(h => ({ label: h.name, category: 'humor' }))
      ];

      // Store tag names for copying
      const tagNames = allTags.map(tag => tag.label);

      genomeEl.innerHTML = `
        <div class="stc-concept__genome-header">
          <span class="stc-concept__genome-label">Story DNA</span>
          <button class="stc-concept__genome-copy" title="Copy Story DNA">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
        </div>
        <div class="stc-concept__genome-tags">
          ${allTags.map(tag => `<span class="stc-concept__genome-tag stc-concept__genome-tag--${tag.category}">${tag.label}</span>`).join('')}
        </div>
      `;

      // Set up genome copy button
      const genomeCopyBtn = genomeEl.querySelector('.stc-concept__genome-copy');
      genomeCopyBtn.onclick = async () => {
        try {
          await navigator.clipboard.writeText(tagNames.join(', '));
          genomeCopyBtn.classList.add('stc-concept__genome-copy--success');
          setTimeout(() => {
            genomeCopyBtn.classList.remove('stc-concept__genome-copy--success');
          }, 1500);
        } catch (err) {
          console.error('Failed to copy genome:', err);
        }
      };
    }

    // Parse and render sections
    currentSections = parseConcept(conceptText);
    contentEl.innerHTML = currentSections.map((section, i) => renderSection(section, i)).join('');

    // Populate combined view
    combinedTextEl.textContent = formatConceptForCopy();

    // Attach event listeners to section buttons
    attachSectionListeners(contentEl);

    // Set up view toggle (reset to sections view)
    setupViewToggle();

    resultEl.style.display = 'block';
    btnRegenerate.style.display = 'inline-block';

    // Show characters section now that concept exists
    updateCharactersVisibility();
  }

  function formatConceptForCopy() {
    // Build genome line as comma-separated tags
    let genomeLine = '';
    if (currentProject?.genome) {
      const hydrated = hydrateGenome(currentProject.genome);
      const allTags = [
        ...hydrated.genres.map(g => g.name),
        ...hydrated.archetypes.map(a => a.name),
        ...hydrated.themes.map(t => t.name),
        ...hydrated.tones.map(t => t.name),
        ...hydrated.stakes.map(s => s.name),
        ...(hydrated.humorRole && hydrated.humorRole.id !== 'none' ? [hydrated.humorRole.name] : []),
        ...hydrated.humorStyles.map(h => h.name)
      ];
      if (allTags.length > 0) {
        genomeLine = `**Story DNA:** ${allTags.join(', ')}\n\n`;
      }
    }

    // Format sections into clean, copyable text
    const sectionsText = currentSections.map(section => `### ${section.name}\n${section.content}`).join('\n\n');

    return genomeLine + sectionsText;
  }

  function setupViewToggle() {
    const toggleBtns = document.querySelectorAll('.stc-concept__view-btn');
    const sectionsView = document.getElementById('concept-content');
    const combinedView = document.getElementById('concept-combined');
    const copyBtn = document.querySelector('.stc-concept__copy-btn');

    // Reset to sections view
    toggleBtns.forEach(btn => btn.classList.remove('stc-concept__view-btn--active'));
    document.querySelector('[data-view="sections"]').classList.add('stc-concept__view-btn--active');
    sectionsView.style.display = 'block';
    combinedView.style.display = 'none';

    // Set up toggle click handlers
    toggleBtns.forEach(btn => {
      btn.onclick = () => {
        const view = btn.dataset.view;

        // Update active states
        toggleBtns.forEach(b => b.classList.remove('stc-concept__view-btn--active'));
        btn.classList.add('stc-concept__view-btn--active');

        // Show/hide views
        if (view === 'sections') {
          sectionsView.style.display = 'block';
          combinedView.style.display = 'none';
        } else {
          sectionsView.style.display = 'none';
          combinedView.style.display = 'block';
          // Update combined text in case sections were edited
          document.getElementById('concept-combined-text').textContent = formatConceptForCopy();
        }
      };
    });

    // Set up copy button
    copyBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(formatConceptForCopy());

        // Visual feedback
        const textEl = copyBtn.querySelector('.stc-concept__copy-text');
        const originalText = textEl.textContent;
        copyBtn.classList.add('stc-concept__copy-btn--success');
        textEl.textContent = 'Copied!';

        setTimeout(() => {
          copyBtn.classList.remove('stc-concept__copy-btn--success');
          textEl.textContent = originalText;
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    };
  }

  function attachSectionListeners(container) {
    container.querySelectorAll('.stc-section').forEach(sectionEl => {
      const index = parseInt(sectionEl.dataset.sectionIndex);

      // Edit button
      sectionEl.querySelector('.stc-section__btn--edit').addEventListener('click', () => {
        enterEditMode(sectionEl, index);
      });

      // Refine button
      sectionEl.querySelector('.stc-section__btn--refine').addEventListener('click', () => {
        enterRefineMode(sectionEl, index);
      });

      // Cancel edit
      sectionEl.querySelector('.stc-section__cancel-edit').addEventListener('click', () => {
        exitEditMode(sectionEl, index);
      });

      // Save edit
      sectionEl.querySelector('.stc-section__save-edit').addEventListener('click', () => {
        saveEdit(sectionEl, index);
      });

      // Cancel refine
      sectionEl.querySelector('.stc-section__cancel-refine').addEventListener('click', () => {
        exitRefineMode(sectionEl);
      });

      // Send to Claude
      sectionEl.querySelector('.stc-section__send-refine').addEventListener('click', () => {
        sendRefineRequest(sectionEl, index);
      });

      // Discard suggestion
      sectionEl.querySelector('.stc-section__discard').addEventListener('click', () => {
        discardSuggestion(sectionEl);
      });

      // Try again
      sectionEl.querySelector('.stc-section__try-again').addEventListener('click', () => {
        tryAgain(sectionEl, index);
      });

      // Keep suggestion
      sectionEl.querySelector('.stc-section__keep').addEventListener('click', () => {
        keepSuggestion(sectionEl, index);
      });
    });

    // Character token click handler (event delegation)
    // Only add once - check for marker to prevent duplicates
    if (!container.dataset.characterTokensEnabled) {
      container.dataset.characterTokensEnabled = 'true';
      container.addEventListener('click', (e) => {
        if (e.target.classList.contains('character-token')) {
          const charId = e.target.dataset.characterId;
          const character = currentCharacters.find(c => c.id === charId);
          if (character) {
            openCharacterSheet(character);
          }
        }
      });
    }
  }

  function enterEditMode(sectionEl, index) {
    sectionEl.querySelector('.stc-section__display').style.display = 'none';
    sectionEl.querySelector('.stc-section__actions').style.display = 'none';
    sectionEl.querySelector('.stc-section__edit-mode').style.display = 'block';
    sectionEl.querySelector('.stc-section__textarea').value = currentSections[index].content;
    sectionEl.querySelector('.stc-section__textarea').focus();
  }

  function exitEditMode(sectionEl, index) {
    sectionEl.querySelector('.stc-section__edit-mode').style.display = 'none';
    sectionEl.querySelector('.stc-section__display').style.display = 'block';
    sectionEl.querySelector('.stc-section__actions').style.display = 'flex';
  }

  async function saveEdit(sectionEl, index) {
    const newContent = sectionEl.querySelector('.stc-section__textarea').value.trim();
    currentSections[index].content = newContent;

    // Update display
    sectionEl.querySelector('.stc-section__display').innerHTML = formatSectionContent(newContent);
    exitEditMode(sectionEl, index);

    // Save to database
    await saveConceptSections();
  }

  function enterRefineMode(sectionEl, index) {
    // Keep display visible so user can read the text while writing direction
    sectionEl.querySelector('.stc-section__actions').style.display = 'none';
    sectionEl.querySelector('.stc-section__refine-mode').style.display = 'block';
    sectionEl.querySelector('.stc-section__direction').value = '';
    sectionEl.querySelector('.stc-section__direction').focus();
  }

  function exitRefineMode(sectionEl) {
    sectionEl.querySelector('.stc-section__refine-mode').style.display = 'none';
    sectionEl.querySelector('.stc-section__suggestion').style.display = 'none';
    sectionEl.querySelector('.stc-section__actions').style.display = 'flex';
  }

  async function sendRefineRequest(sectionEl, index) {
    const direction = sectionEl.querySelector('.stc-section__direction').value.trim();
    const section = currentSections[index];

    // Show loading state
    const sendBtn = sectionEl.querySelector('.stc-section__send-refine');
    const originalText = sendBtn.textContent;
    sendBtn.textContent = 'Thinking...';
    sendBtn.disabled = true;
    showAIOverlay('Refining Section', `Claude is reworking "${section.name}"...`);

    try {
      const hydratedGenome = hydrateGenome(currentProject.genome);

      // Send ALL sections for context-aware refinement
      const response = await fetch('/.netlify/functions/refine-section', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sectionName: section.name,
          allSections: currentSections,
          direction: direction,
          genome: hydratedGenome,
          braindump: currentBraindump?.raw_input || ''
        })
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Netlify function not available. Run "netlify dev" locally or deploy to Netlify.');
      }

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to refine section');
      }

      // Show suggestion
      sectionEl.querySelector('.stc-section__refine-mode').style.display = 'none';
      sectionEl.querySelector('.stc-section__suggestion').style.display = 'block';
      sectionEl.querySelector('.stc-section__suggestion-content').innerHTML = formatSectionContent(data.revisedSection);
      sectionEl.dataset.suggestionContent = data.revisedSection;

      // Handle affected sections if any
      const affectedEl = sectionEl.querySelector('.stc-section__affected');
      const affectedListEl = sectionEl.querySelector('.stc-section__affected-list');

      if (data.affectedSections && data.affectedSections.length > 0) {
        affectedEl.style.display = 'block';
        affectedListEl.innerHTML = data.affectedSections.map((affected, i) => `
          <div class="stc-affected-item" data-affected-index="${i}">
            <div class="stc-affected-item__header">
              <strong>${affected.section}</strong>
            </div>
            <div class="stc-affected-item__reason">${affected.reason}</div>
            <div class="stc-affected-item__fix">
              <div class="stc-affected-item__fix-label">Suggested fix:</div>
              <div class="stc-affected-item__fix-content">${formatSectionContent(affected.suggestedFix)}</div>
            </div>
            <div class="stc-affected-item__actions">
              <button class="button button--small button--secondary stc-affected-item__ignore">Ignore</button>
              <button class="button button--small button--primary stc-affected-item__apply">Apply Fix</button>
            </div>
          </div>
        `).join('');

        // Store affected sections data
        sectionEl.dataset.affectedSections = JSON.stringify(data.affectedSections);

        // Attach event listeners to affected section buttons
        affectedListEl.querySelectorAll('.stc-affected-item').forEach((itemEl, i) => {
          itemEl.querySelector('.stc-affected-item__ignore').addEventListener('click', () => {
            itemEl.remove();
            // Hide affected container if no more items
            if (affectedListEl.children.length === 0) {
              affectedEl.style.display = 'none';
            }
          });

          itemEl.querySelector('.stc-affected-item__apply').addEventListener('click', async () => {
            const affectedData = data.affectedSections[i];
            await applyAffectedFix(affectedData.section, affectedData.suggestedFix);
            itemEl.classList.add('stc-affected-item--applied');
            itemEl.querySelector('.stc-affected-item__actions').innerHTML = '<span class="stc-affected-item__applied-label">‚úì Applied</span>';
          });
        });
      } else {
        affectedEl.style.display = 'none';
        affectedListEl.innerHTML = '';
      }

    } catch (e) {
      console.error('Refine error:', e);
      alert('Error: ' + e.message);
    } finally {
      sendBtn.textContent = originalText;
      sendBtn.disabled = false;
      hideAIOverlay();
    }
  }

  async function applyAffectedFix(sectionName, newContent) {
    // Find the section by name and update it
    const sectionIndex = currentSections.findIndex(s => s.name === sectionName);
    if (sectionIndex === -1) {
      console.error('Could not find section:', sectionName);
      return;
    }

    // Update the section content
    currentSections[sectionIndex].content = newContent;

    // Update the display for that section
    const sectionEl = document.querySelector(`[data-section-index="${sectionIndex}"]`);
    if (sectionEl) {
      sectionEl.querySelector('.stc-section__display').innerHTML = formatSectionContent(newContent);
      sectionEl.querySelector('.stc-section__textarea').value = newContent;
    }

    // Save to database
    await saveConceptSections();
  }

  function discardSuggestion(sectionEl) {
    exitRefineMode(sectionEl);
  }

  function tryAgain(sectionEl, index) {
    sectionEl.querySelector('.stc-section__suggestion').style.display = 'none';
    sectionEl.querySelector('.stc-section__refine-mode').style.display = 'block';
    sectionEl.querySelector('.stc-section__direction').focus();
  }

  async function keepSuggestion(sectionEl, index) {
    const newContent = sectionEl.dataset.suggestionContent;
    currentSections[index].content = newContent;

    // Update display
    sectionEl.querySelector('.stc-section__display').innerHTML = formatSectionContent(newContent);
    sectionEl.querySelector('.stc-section__textarea').value = newContent;
    exitRefineMode(sectionEl);

    // Save to database
    await saveConceptSections();
  }

  function reconstructConceptText() {
    // Rebuild the full concept text from sections
    let text = '## Story Concept\n\n';
    currentSections.forEach(section => {
      text += `### ${section.name}\n${section.content}\n\n`;
    });
    return text.trim();
  }

  async function saveConceptSections() {
    if (!currentProject) {
      console.error('saveConceptSections: No current project');
      return;
    }

    const conceptText = reconstructConceptText();
    console.log('Saving concept sections, text length:', conceptText.length);

    // Build the story_concept object, handling case where it might be null
    const existingConcept = currentProject.story_concept || {};
    const updatedConcept = {
      ...existingConcept,
      concept: conceptText,
      updated_at: new Date().toISOString()
    };

    try {
      const { data, error } = await supabase
        .from('projects')
        .update({ story_concept: updatedConcept })
        .eq('id', currentProject.id)
        .select();

      if (error) throw error;

      console.log('Save successful:', data);

      // Update local state
      currentProject.story_concept = updatedConcept;

      showConceptStatus('Saved', 'success');
    } catch (e) {
      console.error('Save error:', e);
      showConceptStatus('Save failed', 'error');
    }
  }

  async function saveConcept(conceptText) {
    if (!currentProject) return;

    try {
      // Save to projects table as story_concept JSON field
      const { error } = await supabase
        .from('projects')
        .update({
          story_concept: {
            concept: conceptText,
            generated_at: new Date().toISOString()
          }
        })
        .eq('id', currentProject.id);

      if (error) throw error;

      // Update local state
      currentProject.story_concept = {
        concept: conceptText,
        generated_at: new Date().toISOString()
      };

      showConceptStatus('Concept saved!', 'success');
    } catch (e) {
      console.error('Save concept error:', e);
      showConceptStatus('Failed to save', 'error');
    }
  }

  function showConceptError(message) {
    const errorEl = document.getElementById('concept-error');
    const errorMsg = document.getElementById('concept-error-message');
    const btnGenerate = document.getElementById('btn-generate-concept');

    errorMsg.textContent = message;
    errorEl.style.display = 'block';
    btnGenerate.style.display = 'inline-block';
  }

  function showConceptStatus(message, type) {
    const status = document.getElementById('concept-status');
    status.textContent = message;
    status.className = `stc-concept__status stc-concept__status--${type}`;

    setTimeout(() => {
      status.textContent = '';
      status.className = 'stc-concept__status';
    }, 3000);
  }

  function updateConceptUI() {
    const btnGenerate = document.getElementById('btn-generate-concept');
    const noteEl = document.getElementById('concept-note');
    const readyEl = document.getElementById('concept-ready');
    const readyGenomeEl = document.getElementById('concept-ready-genome');
    const resultEl = document.getElementById('concept-result');
    const contentEl = document.getElementById('concept-content');
    const btnRegenerate = document.getElementById('btn-regenerate-concept');

    // Check if we have a genome saved
    const hasGenome = currentProject?.genome &&
      Object.values(currentProject.genome).some(v =>
        Array.isArray(v) ? v.length > 0 : (v && v !== 'none')
      );

    // Check if we have an existing concept
    const hasConcept = currentProject?.story_concept?.concept;

    if (hasConcept) {
      // Has concept - show result, hide ready state
      btnGenerate.style.display = 'inline-block';
      noteEl.style.display = 'none';
      readyEl.style.display = 'none';
      displayConcept(currentProject.story_concept.concept);
    } else if (hasGenome) {
      // Has genome but no concept - show ready state with genome pills
      btnGenerate.style.display = 'none'; // Hide header button
      noteEl.style.display = 'none';
      readyEl.style.display = 'block';
      resultEl.style.display = 'none';
      btnRegenerate.style.display = 'none';

      // Populate genome pills
      populateGenomePills(readyGenomeEl, currentProject.genome);
    } else {
      // No genome yet - show prompt
      btnGenerate.style.display = 'none';
      noteEl.style.display = 'block';
      noteEl.textContent = 'Apply your genome to unlock AI-powered story concept generation.';
      readyEl.style.display = 'none';
      resultEl.style.display = 'none';
      btnRegenerate.style.display = 'none';
    }
  }

  function populateGenomePills(container, genome) {
    container.innerHTML = '';
    const hydrated = hydrateGenome(genome);

    // Helper to get display label from value (could be object or string)
    const getLabel = (v) => {
      if (typeof v === 'object' && v !== null) {
        return v.label || v.name || String(v);
      }
      return String(v);
    };

    // Add pills for each genome category
    const categories = [
      { key: 'genres', label: 'Genre' },
      { key: 'subgenres', label: 'Subgenre' },
      { key: 'tones', label: 'Tone' },
      { key: 'themes', label: 'Theme' },
      { key: 'stakes', label: 'Stakes' },
      { key: 'humorRole', label: 'Humor Role', isSingle: true },
      { key: 'humorStyle', label: 'Humor Style' }
    ];

    categories.forEach(cat => {
      const value = hydrated[cat.key];
      if (cat.isSingle) {
        if (value && value !== 'none' && value !== 'None') {
          const displayVal = getLabel(value);
          if (displayVal && displayVal !== 'none' && displayVal !== 'None') {
            const pill = document.createElement('span');
            pill.className = 'stc-concept__pill';
            pill.innerHTML = `<span class="stc-concept__pill-label">${cat.label}:</span> ${displayVal}`;
            container.appendChild(pill);
          }
        }
      } else if (Array.isArray(value) && value.length > 0) {
        value.forEach(v => {
          const displayVal = getLabel(v);
          const pill = document.createElement('span');
          pill.className = 'stc-concept__pill';
          pill.innerHTML = `<span class="stc-concept__pill-label">${cat.label}:</span> ${displayVal}`;
          container.appendChild(pill);
        });
      }
    });
  }

  // View switching
  function showListView(skipURLUpdate = false) {
    listView.style.display = 'block';
    diveView.style.display = 'none';
    currentBraindump = null;
    currentProject = null;

    if (!skipURLUpdate) {
      updateURL('list', null);
    }

    // Load braindumps if not already loaded
    loadBraindumps();
  }

  function showDiveView(braindump, project, skipURLUpdate = false) {
    currentBraindump = braindump;
    currentProject = project;

    listView.style.display = 'none';
    diveView.style.display = 'block';

    if (!skipURLUpdate) {
      updateURL('dive', braindump.id);
    }

    diveTimestamp.textContent = new Date(braindump.created_at).toLocaleString();
    diveContent.textContent = braindump.raw_input;
    diveTextarea.value = braindump.raw_input;

    // Set accordion preview text (first ~80 chars)
    const previewText = braindump.raw_input.substring(0, 80).replace(/\n/g, ' ');
    document.getElementById('braindump-preview').textContent =
      previewText + (braindump.raw_input.length > 80 ? '...' : '');

    // Set project title
    const briefTitleEl = document.getElementById('brief-title');
    const projectTitle = project?.title || 'Untitled Story';
    const isGenerating = projectTitle === 'Braindump Session';
    briefTitleEl.textContent = isGenerating ? 'Generating title...' : projectTitle;
    briefTitleEl.classList.toggle('stc-brief__title--generating', isGenerating);

    // Start accordion collapsed
    const accordion = document.getElementById('braindump-accordion');
    accordion.classList.remove('stc-braindump-accordion--expanded');

    // Reset to display mode
    diveDisplay.style.display = 'block';
    diveEdit.style.display = 'none';

    // Initialize spine builder
    renderVertebrae();

    // Load existing genome or reset to defaults
    if (project && project.genome) {
      loadGenomeIntoUI(project.genome);
      // Update button text since genome has been saved before
      document.getElementById('btn-save-genome').textContent = 'Apply Genome Changes';
    } else {
      resetSpineSelections();
    }

    // Update concept section UI
    updateConceptUI();

    // Initialize brief section
    initializeBriefSection(project);

    // Load characters and update visibility
    if (project) {
      loadCharacters(project.id);
    }
    updateCharactersVisibility();
  }

  // Brief state
  let pendingBrief = null; // Holds extracted but not-yet-accepted brief

  function initializeBriefSection(project) {
    const emptyEl = document.getElementById('brief-empty');
    const loadingEl = document.getElementById('brief-loading');
    const displayEl = document.getElementById('brief-display');
    const pendingActionsEl = document.getElementById('brief-pending-actions');
    const lockedIndicatorEl = document.getElementById('brief-locked-indicator');

    // Check if we have a locked brief
    if (project?.brief?.locked) {
      // Show locked state
      showBriefLocked(project.brief);
    } else if (project?.brief?.coreConcept) {
      // Has brief but not locked - show pending state
      pendingBrief = project.brief;
      showBriefPending(project.brief);
    } else {
      // No brief yet - show extract button
      emptyEl.style.display = 'block';
      loadingEl.style.display = 'none';
      displayEl.style.display = 'none';
    }
  }

  function showBriefPending(brief) {
    const emptyEl = document.getElementById('brief-empty');
    const loadingEl = document.getElementById('brief-loading');
    const displayEl = document.getElementById('brief-display');
    const pendingActionsEl = document.getElementById('brief-pending-actions');
    const lockedIndicatorEl = document.getElementById('brief-locked-indicator');

    document.getElementById('brief-concept').textContent = brief.coreConcept || '';
    document.getElementById('brief-premise').textContent = brief.premise || '';
    document.getElementById('brief-world').textContent = brief.worldAndTone || '';

    emptyEl.style.display = 'none';
    loadingEl.style.display = 'none';
    displayEl.style.display = 'block';
    pendingActionsEl.style.display = 'flex';
    lockedIndicatorEl.style.display = 'none';

    // Enable edit buttons
    displayEl.querySelectorAll('.stc-brief__item-edit').forEach(btn => {
      btn.style.display = 'inline-flex';
    });
  }

  function showBriefLocked(brief) {
    const emptyEl = document.getElementById('brief-empty');
    const loadingEl = document.getElementById('brief-loading');
    const displayEl = document.getElementById('brief-display');
    const pendingActionsEl = document.getElementById('brief-pending-actions');
    const lockedIndicatorEl = document.getElementById('brief-locked-indicator');

    document.getElementById('brief-concept').textContent = brief.coreConcept || '';
    document.getElementById('brief-premise').textContent = brief.premise || '';
    document.getElementById('brief-world').textContent = brief.worldAndTone || '';

    emptyEl.style.display = 'none';
    loadingEl.style.display = 'none';
    displayEl.style.display = 'block';
    pendingActionsEl.style.display = 'none';
    lockedIndicatorEl.style.display = 'flex';

    // Hide edit buttons when locked
    displayEl.querySelectorAll('.stc-brief__item-edit').forEach(btn => {
      btn.style.display = 'none';
    });
  }

  async function extractBrief() {
    const emptyEl = document.getElementById('brief-empty');
    const loadingEl = document.getElementById('brief-loading');

    emptyEl.style.display = 'none';
    loadingEl.style.display = 'flex';
    showAIOverlay('Extracting Brief...', 'Claude is analyzing your braindump');

    try {
      const response = await fetch('/.netlify/functions/extract-brief', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ braindump: currentBraindump.raw_input })
      });

      if (!response.ok) {
        throw new Error('Brief extraction failed');
      }

      const data = await response.json();

      pendingBrief = {
        coreConcept: data.coreConcept,
        premise: data.premise,
        worldAndTone: data.worldAndTone,
        locked: false
      };

      showBriefPending(pendingBrief);

      // Save pending brief to database (not locked yet)
      await saveBriefToDatabase(pendingBrief);

    } catch (err) {
      console.error('Brief extraction error:', err);
      emptyEl.style.display = 'block';
      loadingEl.style.display = 'none';
      showBriefStatus('Extraction failed - try again', 'error');
    } finally {
      hideAIOverlay();
    }
  }

  async function acceptBrief() {
    if (!pendingBrief) return;

    pendingBrief.locked = true;
    await saveBriefToDatabase(pendingBrief);
    currentProject.brief = pendingBrief;

    showBriefLocked(pendingBrief);
    showBriefStatus('Brief locked!', 'success');
  }

  async function unlockBrief() {
    if (!currentProject?.brief) return;

    currentProject.brief.locked = false;
    pendingBrief = currentProject.brief;
    await saveBriefToDatabase(pendingBrief);

    showBriefPending(pendingBrief);
  }

  async function saveBriefToDatabase(brief) {
    if (!currentProject) return;

    const { error } = await supabase
      .from('projects')
      .update({ brief: brief })
      .eq('id', currentProject.id);

    if (error) {
      console.error('Failed to save brief:', error);
    } else {
      currentProject.brief = brief;
    }
  }

  function showBriefStatus(message, type) {
    const statusEl = document.getElementById('brief-status');
    statusEl.textContent = message;
    statusEl.className = `stc-brief__status stc-brief__status--${type}`;

    setTimeout(() => {
      statusEl.textContent = '';
      statusEl.className = 'stc-brief__status';
    }, 3000);
  }

  function setupBriefItemEditing() {
    document.querySelectorAll('.stc-brief__item').forEach(item => {
      const field = item.dataset.field;
      const contentEl = item.querySelector('.stc-brief__content');
      const textareaEl = item.querySelector('.stc-brief__textarea');
      const actionsEl = item.querySelector('.stc-brief__item-actions');
      const editBtn = item.querySelector('.stc-brief__item-edit');
      const cancelBtn = item.querySelector('.stc-brief__item-cancel');
      const saveBtn = item.querySelector('.stc-brief__item-save');

      editBtn?.addEventListener('click', () => {
        textareaEl.value = contentEl.textContent;
        contentEl.style.display = 'none';
        textareaEl.style.display = 'block';
        actionsEl.style.display = 'flex';
        editBtn.style.display = 'none';
        textareaEl.focus();
      });

      cancelBtn?.addEventListener('click', () => {
        contentEl.style.display = 'block';
        textareaEl.style.display = 'none';
        actionsEl.style.display = 'none';
        editBtn.style.display = 'inline-flex';
      });

      saveBtn?.addEventListener('click', async () => {
        const newValue = textareaEl.value.trim();
        contentEl.textContent = newValue;

        // Update pending brief
        if (pendingBrief) {
          pendingBrief[field] = newValue;
          await saveBriefToDatabase(pendingBrief);
        }

        contentEl.style.display = 'block';
        textareaEl.style.display = 'none';
        actionsEl.style.display = 'none';
        editBtn.style.display = 'inline-flex';
      });
    });
  }

  // Save new braindump
  // Generate AI title for a project (runs in background)
  async function generateProjectTitle(projectId, braindumpContent) {
    try {
      const response = await fetch('/.netlify/functions/generate-title', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ braindump: braindumpContent })
      });

      if (!response.ok) {
        console.error('Title generation failed');
        return;
      }

      const data = await response.json();
      const title = data.title || 'Untitled Story';

      // Save to database
      const { error } = await supabase
        .from('projects')
        .update({ title: title })
        .eq('id', projectId);

      if (error) {
        console.error('Failed to save title:', error);
        return;
      }

      // Update current project if it's the same one
      if (currentProject && currentProject.id === projectId) {
        currentProject.title = title;
      }

      // Refresh the list to show new title
      await loadBraindumps();

    } catch (err) {
      console.error('Title generation error:', err);
    }
  }

  // Save project title to database
  async function saveProjectTitle(projectId, title) {
    try {
      const { error } = await supabase
        .from('projects')
        .update({ title: title })
        .eq('id', projectId);

      if (error) {
        console.error('Failed to save title:', error);
      }

      // Update current project if it matches
      if (currentProject && currentProject.id === projectId) {
        currentProject.title = title;
        // Update title display in brief section if visible
        const briefTitleEl = document.getElementById('brief-title');
        if (briefTitleEl) {
          briefTitleEl.textContent = title;
        }
      }
    } catch (err) {
      console.error('Save title error:', err);
    }
  }

  async function saveBraindump() {
    const content = textarea.value.trim();

    if (!content) {
      showError('Please enter your idea first!');
      return;
    }

    btnSave.disabled = true;
    btnSave.textContent = 'Saving...';

    try {
      // Create project with user's ID
      const { data: project, error: projectError } = await supabase
        .from('projects')
        .insert({
          title: 'Braindump Session',
          status: 'braindump',
          user_id: currentUser.id,
        })
        .select()
        .single();

      if (projectError) throw new Error(`Project creation failed: ${projectError.message}`);

      // Save braindump
      const { data: braindump, error: braindumpError } = await supabase
        .from('braindumps')
        .insert({
          project_id: project.id,
          raw_input: content,
        })
        .select()
        .single();

      if (braindumpError) throw new Error(`Braindump save failed: ${braindumpError.message}`);

      // Store for "dive into new" link
      currentBraindump = braindump;
      currentProject = project;

      // Show success
      errorPanel.style.display = 'none';
      resultPanel.style.display = 'block';
      textarea.value = '';

      // Generate title in background (don't block)
      generateProjectTitle(project.id, content);

      // Refresh table
      await loadBraindumps();

    } catch (e) {
      showError(e.message);
    } finally {
      btnSave.disabled = false;
      btnSave.textContent = 'Save My Braindump';
    }
  }

  function showError(message) {
    resultPanel.style.display = 'none';
    errorPanel.style.display = 'block';
    document.getElementById('error-message').textContent = message;
  }

  // Load existing braindumps for current user
  async function loadBraindumps() {
    const tbody = document.getElementById('braindumps-body');

    if (!currentUser) {
      tbody.innerHTML = '<tr><td colspan="3" class="empty">Sign in to see your braindumps</td></tr>';
      return;
    }

    try {
      // Join with projects to filter by user_id and get title
      const { data, error } = await supabase
        .from('braindumps')
        .select('id, raw_input, created_at, project_id, projects!inner(user_id, title)')
        .eq('projects.user_id', currentUser.id)
        .order('created_at', { ascending: false })
        .limit(10);

      if (error) {
        tbody.innerHTML = `<tr><td colspan="3" class="error">Error: ${error.message}</td></tr>`;
        return;
      }

      if (!data || data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" class="empty">No braindumps yet. Add your first idea above!</td></tr>';
        return;
      }

      tbody.innerHTML = data.map(row => {
        const title = row.projects?.title || 'Untitled';
        const isGenerating = title === 'Braindump Session';
        return `
        <tr>
          <td class="title-cell">
            <span class="project-title ${isGenerating ? 'project-title--generating' : ''}"
                  data-project-id="${row.project_id}"
                  contenteditable="true"
                  spellcheck="false">${escapeHtml(isGenerating ? 'Generating title...' : title)}</span>
          </td>
          <td class="content">${escapeHtml(truncate(row.raw_input, 60))}</td>
          <td class="action">
            <button class="button button--small button--primary dive-btn" data-id="${row.id}" data-project="${row.project_id}">Dive in</button>
          </td>
        </tr>
      `}).join('');

      // Attach click handlers for dive buttons
      tbody.querySelectorAll('.dive-btn').forEach(btn => {
        btn.addEventListener('click', () => diveIntoBraindump(btn.dataset.id));
      });

      // Attach blur handlers for title editing
      tbody.querySelectorAll('.project-title').forEach(titleEl => {
        titleEl.addEventListener('blur', async () => {
          const projectId = titleEl.dataset.projectId;
          const newTitle = titleEl.textContent.trim();
          if (newTitle && newTitle !== 'Generating title...') {
            await saveProjectTitle(projectId, newTitle);
          }
        });
        titleEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            titleEl.blur();
          }
        });
      });

    } catch (e) {
      tbody.innerHTML = `<tr><td colspan="3" class="error">Error: ${e.message}</td></tr>`;
    }
  }

  // Dive into a braindump
  async function diveIntoBraindump(braindumpId, skipURLUpdate = false) {
    try {
      const { data: braindump, error } = await supabase
        .from('braindumps')
        .select('*, projects(*)')
        .eq('id', braindumpId)
        .single();

      if (error) throw error;

      showDiveView(braindump, braindump.projects, skipURLUpdate);
    } catch (e) {
      showError(`Failed to load braindump: ${e.message}`);
      // If deep link fails, go back to list
      showListView(skipURLUpdate);
    }
  }

  // Braindump edit mode
  function enterBraindumpEditMode() {
    diveDisplay.style.display = 'none';
    diveEdit.style.display = 'block';
    diveTextarea.focus();
  }

  function exitBraindumpEditMode() {
    diveDisplay.style.display = 'block';
    diveEdit.style.display = 'none';
    diveTextarea.value = currentBraindump.raw_input; // Reset
  }

  async function saveBraindumpEdit() {
    const newContent = diveTextarea.value.trim();
    if (!newContent) return;

    btnSaveEdit.disabled = true;
    btnSaveEdit.textContent = 'Saving...';

    try {
      const { data, error } = await supabase
        .from('braindumps')
        .update({ raw_input: newContent })
        .eq('id', currentBraindump.id)
        .select()
        .single();

      if (error) throw error;

      currentBraindump = data;
      diveContent.textContent = data.raw_input;
      exitBraindumpEditMode();

    } catch (e) {
      alert(`Failed to save: ${e.message}`);
    } finally {
      btnSaveEdit.disabled = false;
      btnSaveEdit.textContent = 'Save Changes';
    }
  }

  // Helpers
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function truncate(text, len) {
    return text.length > len ? text.substring(0, len) + '...' : text;
  }

  // Toast notification system
  let toastIdCounter = 0;

  function showToast(message, type = 'info', duration = 3000) {
    const container = document.getElementById('toast-container');
    const toastId = `toast-${++toastIdCounter}`;

    const iconHtml = type === 'checking'
      ? '<div class="stc-toast__spinner"></div>'
      : type === 'success'
        ? '<svg class="stc-toast__icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>'
        : '<svg class="stc-toast__icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>';

    const toast = document.createElement('div');
    toast.id = toastId;
    toast.className = `stc-toast stc-toast--${type}`;
    toast.innerHTML = `${iconHtml}<span>${escapeHtml(message)}</span>`;

    container.appendChild(toast);

    // Auto-remove after duration (unless duration is 0 for persistent toasts)
    if (duration > 0) {
      setTimeout(() => removeToast(toastId), duration);
    }

    return toastId;
  }

  function removeToast(toastId) {
    const toast = document.getElementById(toastId);
    if (toast) {
      toast.classList.add('stc-toast--exiting');
      setTimeout(() => toast.remove(), 300);
    }
  }

  function updateToast(toastId, message, type) {
    const toast = document.getElementById(toastId);
    if (toast) {
      toast.className = `stc-toast stc-toast--${type}`;
      const iconHtml = type === 'checking'
        ? '<div class="stc-toast__spinner"></div>'
        : type === 'success'
          ? '<svg class="stc-toast__icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>'
          : '<svg class="stc-toast__icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>';
      toast.innerHTML = `${iconHtml}<span>${escapeHtml(message)}</span>`;
    }
  }

  // AI Loading Overlay
  function showAIOverlay(title = 'Claude is thinking...', message = 'This may take a moment') {
    const overlay = document.getElementById('ai-overlay');
    document.getElementById('ai-overlay-title').textContent = title;
    document.getElementById('ai-overlay-message').textContent = message;
    document.body.style.overflow = 'hidden';
    overlay.style.display = 'flex';
  }

  function hideAIOverlay() {
    const overlay = document.getElementById('ai-overlay');
    overlay.style.display = 'none';
    document.body.style.overflow = '';
  }

  // Event listeners - Auth
  btnGoogleSignin.addEventListener('click', signInWithGoogle);
  btnSignout.addEventListener('click', signOut);

  // Event listeners - Braindumps
  btnSave.addEventListener('click', saveBraindump);
  btnBack.addEventListener('click', () => showListView()); // User clicked, so update URL
  btnEdit.addEventListener('click', enterBraindumpEditMode);
  btnCancelEdit.addEventListener('click', exitBraindumpEditMode);
  btnSaveEdit.addEventListener('click', saveBraindumpEdit);

  // Event listener - Braindump accordion toggle
  document.getElementById('braindump-toggle').addEventListener('click', () => {
    const accordion = document.getElementById('braindump-accordion');
    accordion.classList.toggle('stc-braindump-accordion--expanded');
  });

  // Event listener - Genome
  document.getElementById('btn-save-genome').addEventListener('click', saveGenome);

  // Event listeners - Story Concept
  document.getElementById('btn-generate-concept').addEventListener('click', generateStoryConcept);
  document.getElementById('btn-generate-concept-cta').addEventListener('click', generateStoryConcept);
  document.getElementById('btn-regenerate-concept').addEventListener('click', generateStoryConcept);

  // Event listeners - Brief
  document.getElementById('btn-extract-brief').addEventListener('click', extractBrief);
  document.getElementById('btn-reextract-brief').addEventListener('click', extractBrief);
  document.getElementById('btn-accept-brief').addEventListener('click', acceptBrief);
  document.getElementById('btn-unlock-brief').addEventListener('click', unlockBrief);

  // Event listener - Project title editing
  const briefTitleEl = document.getElementById('brief-title');
  briefTitleEl.addEventListener('blur', async () => {
    if (!currentProject) return;
    const newTitle = briefTitleEl.textContent.trim();
    if (newTitle && newTitle !== 'Generating title...') {
      await saveProjectTitle(currentProject.id, newTitle);
    }
  });
  briefTitleEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      briefTitleEl.blur();
    }
  });

  // Event listener - Regenerate title button
  document.getElementById('btn-regenerate-title').addEventListener('click', async () => {
    if (!currentProject || !currentBraindump) return;

    const btn = document.getElementById('btn-regenerate-title');
    const titleEl = document.getElementById('brief-title');

    btn.disabled = true;
    btn.classList.add('stc-brief__title-regen--loading');
    titleEl.textContent = 'Generating...';
    titleEl.classList.add('stc-brief__title--generating');

    await generateProjectTitle(currentProject.id, currentBraindump.raw_input);

    // Update the title display (generateProjectTitle updates currentProject.title)
    titleEl.textContent = currentProject.title || 'Untitled Story';
    titleEl.classList.remove('stc-brief__title--generating');
    btn.disabled = false;
    btn.classList.remove('stc-brief__title-regen--loading');
  });

  // Setup brief item editing (inline edit buttons)
  setupBriefItemEditing();

  // ========== CHARACTER SYSTEM ==========

  // Character role definitions
  const CHARACTER_ROLES = {
    protagonist: {
      label: 'Protagonist',
      tier: 1,
      description: 'Drives the story toward the goal. The perspective we follow.'
    },
    antagonist: {
      label: 'Antagonist',
      tier: 1,
      description: "Opposes the goal. Not necessarily evil‚Äîjust in the way."
    },
    mirror: {
      label: 'Mirror',
      tier: 2,
      description: "Reflects or challenges the protagonist's worldview. Forces growth."
    },
    ally: {
      label: 'Ally',
      tier: 2,
      description: 'Supports the protagonist. Provides faith, help, or mentorship.'
    },
    skeptic: {
      label: 'Skeptic',
      tier: 2,
      description: 'Questions and doubts. Keeps the protagonist honest.'
    },
    wildcard: {
      label: 'Wildcard',
      tier: 2,
      description: "Doesn't fit neatly. Comic relief, love interest, or chaos agent."
    }
  };

  const ARC_TYPES = {
    'positive-change': {
      label: 'Positive Change',
      description: 'Transforms for the better'
    },
    'negative-change': {
      label: 'Negative Change',
      description: 'Transforms for the worse'
    },
    'steadfast': {
      label: 'Steadfast',
      description: 'Holds their ground'
    }
  };

  // Character state
  let currentCharacters = []; // Array of character objects for current project

  // Load characters from database
  async function loadCharacters(projectId) {
    try {
      const { data, error } = await supabase
        .from('characters')
        .select('*')
        .eq('project_id', projectId)
        .order('created_at', { ascending: true });

      if (error) throw error;

      currentCharacters = data || [];
      renderAllCharacterSlots();
      updateCharactersVisibility();
    } catch (e) {
      console.error('Failed to load characters:', e);
      currentCharacters = [];
    }
  }

  // Update visibility of characters section based on whether story concept exists
  function updateCharactersVisibility() {
    const section = document.getElementById('characters-section');
    const devZone = document.getElementById('dev-zone');
    const hasConcept = currentProject?.story_concept?.concept;

    if (hasConcept) {
      section.style.display = 'block';
      devZone.style.display = 'block';
      updateDevZone();
    } else {
      section.style.display = 'none';
      devZone.style.display = 'none';
    }
  }

  // Dev Zone functionality
  function updateDevZone() {
    const output = document.getElementById('dev-entity-test');
    if (!output) return;

    if (currentCharacters.length === 0) {
      output.innerHTML = '<em>Add characters to see entity rendering in action.</em>';
      return;
    }

    // Generate sample text using character names
    const names = currentCharacters.map(c => c.name).filter(Boolean);
    if (names.length === 0) {
      output.innerHTML = '<em>Your characters need names to test entity rendering.</em>';
      return;
    }

    const sampleText = `This is a test paragraph mentioning ${names[0]}. ` +
      (names[1] ? `When ${names[1]} arrives, things get complicated. ` : '') +
      (names[2] ? `Meanwhile, ${names[2]} has their own agenda. ` : '') +
      `The relationship between ${names[0]} and ${names[1] || 'the others'} drives the story forward.`;

    output.innerHTML = renderContentWithEntities(sampleText, currentCharacters);
  }

  // Render all character slots based on currentCharacters
  function renderAllCharacterSlots() {
    // Reset all slots to empty state
    Object.keys(CHARACTER_ROLES).forEach(role => {
      const slot = document.getElementById(`slot-${role}`);
      if (slot) {
        const emptyEl = slot.querySelector('.stc-character-slot__empty');
        const filledEl = slot.querySelector('.stc-character-slot__filled');
        emptyEl.style.display = 'block';
        filledEl.style.display = 'none';
        filledEl.innerHTML = '';
      }
    });

    // Clear extra characters list
    const extraList = document.getElementById('characters-extra-list');
    const extraSection = document.getElementById('characters-extra');
    extraList.innerHTML = '';
    extraSection.style.display = 'none';

    // Place characters in slots or extra area
    const extraCharacters = [];

    currentCharacters.forEach(char => {
      if (char.role && CHARACTER_ROLES[char.role]) {
        renderCharacterInSlot(char);
      } else {
        extraCharacters.push(char);
      }
    });

    // Render extra characters if any
    if (extraCharacters.length > 0) {
      extraSection.style.display = 'block';
      extraCharacters.forEach(char => {
        extraList.appendChild(createCharacterCard(char));
      });
    }

    // Update dev zone with latest character data
    updateDevZone();
  }

  // Render a character in its designated slot
  function renderCharacterInSlot(character) {
    const slot = document.getElementById(`slot-${character.role}`);
    if (!slot) return;

    const emptyEl = slot.querySelector('.stc-character-slot__empty');
    const filledEl = slot.querySelector('.stc-character-slot__filled');

    emptyEl.style.display = 'none';
    filledEl.style.display = 'block';
    filledEl.innerHTML = '';
    filledEl.appendChild(createCharacterCard(character));
  }

  // Create a character card element
  function createCharacterCard(character) {
    const card = document.createElement('div');
    card.className = 'stc-character-card';
    card.dataset.characterId = character.id;

    const arcType = character.arc_type ? ARC_TYPES[character.arc_type] : null;

    card.innerHTML = `
      <h4 class="stc-character-card__name">${escapeHtml(character.name || 'Unnamed')}</h4>
      ${character.want ? `<p class="stc-character-card__want"><strong>Want:</strong> ${escapeHtml(character.want)}</p>` : ''}
      ${character.need ? `<p class="stc-character-card__need"><strong>Need:</strong> ${escapeHtml(character.need)}</p>` : ''}
      ${arcType ? `<span class="stc-character-card__arc">${arcType.label}</span>` : ''}
      <div class="stc-character-card__actions">
        <button class="stc-character-card__view" title="View character sheet">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
            <circle cx="12" cy="12" r="3"/>
          </svg>
          View
        </button>
        <button class="stc-character-card__edit" title="Edit character">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
          </svg>
          Edit
        </button>
      </div>
    `;

    // Attach view handler
    card.querySelector('.stc-character-card__view').addEventListener('click', () => {
      openCharacterSheet(character);
    });

    // Attach edit handler
    card.querySelector('.stc-character-card__edit').addEventListener('click', () => {
      openCharacterModal(character);
    });

    return card;
  }

  // Open character modal for new or existing character
  function openCharacterModal(character = null, defaultRole = null) {
    const modal = document.getElementById('character-modal');
    const title = document.getElementById('character-modal-title');
    const form = document.getElementById('character-form');
    const deleteSection = document.getElementById('character-delete-section');

    // Reset form
    form.reset();

    if (character) {
      // Editing existing character
      title.textContent = 'Edit Character';
      document.getElementById('character-id').value = character.id;
      document.getElementById('character-role').value = character.role || '';
      document.getElementById('character-name').value = character.name || '';
      document.getElementById('character-want').value = character.want || '';
      document.getElementById('character-need').value = character.need || '';
      document.getElementById('character-arc-type').value = character.arc_type || '';
      document.getElementById('character-arc-desc').value = character.arc_description || '';
      document.getElementById('character-connections').value = character.connections || '';
      deleteSection.style.display = 'block';
    } else {
      // New character
      title.textContent = 'New Character';
      document.getElementById('character-id').value = '';
      document.getElementById('character-role').value = defaultRole || '';
      deleteSection.style.display = 'none';
    }

    document.body.style.overflow = 'hidden';
    modal.style.display = 'flex';
    document.getElementById('character-name').focus();
  }

  // Close character modal
  function closeCharacterModal() {
    const modal = document.getElementById('character-modal');
    modal.style.display = 'none';
    document.body.style.overflow = '';
  }

  // Character sheet (read-only view)
  let currentSheetCharacter = null;

  function openCharacterSheet(character) {
    currentSheetCharacter = character;
    const modal = document.getElementById('character-sheet-modal');
    const arcType = character.arc_type ? ARC_TYPES[character.arc_type] : null;
    const roleLabel = CHARACTER_ROLES[character.role]?.label || character.role || 'Character';

    // Populate sheet
    document.getElementById('character-sheet-title').textContent = character.name || 'Unnamed';
    document.getElementById('sheet-role').textContent = roleLabel;
    document.getElementById('sheet-want').textContent = character.want || '‚Äî';
    document.getElementById('sheet-need').textContent = character.need || '‚Äî';
    document.getElementById('sheet-arc-type').textContent = arcType ? arcType.label : '‚Äî';
    document.getElementById('sheet-arc-desc').textContent = character.arc_description || '‚Äî';
    document.getElementById('sheet-connections').textContent = character.connections || '‚Äî';

    document.body.style.overflow = 'hidden';
    modal.style.display = 'flex';
  }

  function closeCharacterSheet() {
    const modal = document.getElementById('character-sheet-modal');
    modal.style.display = 'none';
    document.body.style.overflow = '';
    currentSheetCharacter = null;
  }

  // Save character (create or update)
  async function saveCharacter() {
    if (!currentProject) return;

    const characterId = document.getElementById('character-id').value;
    const characterData = {
      project_id: currentProject.id,
      user_id: currentUser.id,
      role: document.getElementById('character-role').value || null,
      name: document.getElementById('character-name').value.trim(),
      want: document.getElementById('character-want').value.trim() || null,
      need: document.getElementById('character-need').value.trim() || null,
      arc_type: document.getElementById('character-arc-type').value || null,
      arc_description: document.getElementById('character-arc-desc').value.trim() || null,
      connections: document.getElementById('character-connections').value.trim() || null
    };

    if (!characterData.name) {
      alert('Please enter a character name.');
      return;
    }

    // Capture previous character state for cascade analysis
    let previousCharacter = null;
    if (characterId) {
      previousCharacter = currentCharacters.find(c => c.id === characterId);
      if (previousCharacter) {
        previousCharacter = { ...previousCharacter }; // Clone it
      }
    }

    const saveBtn = document.getElementById('btn-character-save');
    saveBtn.disabled = true;
    saveBtn.textContent = 'Saving...';

    let savedCharacter = null;

    try {
      if (characterId) {
        // Update existing
        const { data, error } = await supabase
          .from('characters')
          .update(characterData)
          .eq('id', characterId)
          .select()
          .single();

        if (error) throw error;

        savedCharacter = data;

        // Update in local array
        const index = currentCharacters.findIndex(c => c.id === characterId);
        if (index !== -1) {
          currentCharacters[index] = data;
        }
      } else {
        // Create new
        const { data, error } = await supabase
          .from('characters')
          .insert(characterData)
          .select()
          .single();

        if (error) throw error;

        savedCharacter = data;
        currentCharacters.push(data);
      }

      renderAllCharacterSlots();
      closeCharacterModal();

      // Trigger project-wide cascade check after save
      // This runs asynchronously - don't block the UI
      if (savedCharacter) {
        checkProjectWideCascade(savedCharacter, previousCharacter);
      }
    } catch (e) {
      console.error('Failed to save character:', e);
      alert('Failed to save character: ' + e.message);
    } finally {
      saveBtn.disabled = false;
      saveBtn.textContent = 'Save Character';
    }
  }

  // Delete character
  async function deleteCharacter() {
    const characterId = document.getElementById('character-id').value;
    if (!characterId) return;

    if (!confirm('Delete this character? This cannot be undone.')) return;

    const deleteBtn = document.getElementById('btn-character-delete');
    deleteBtn.disabled = true;
    deleteBtn.textContent = 'Deleting...';

    try {
      const { error } = await supabase
        .from('characters')
        .delete()
        .eq('id', characterId);

      if (error) throw error;

      // Remove from local array
      currentCharacters = currentCharacters.filter(c => c.id !== characterId);
      renderAllCharacterSlots();
      closeCharacterModal();
    } catch (e) {
      console.error('Failed to delete character:', e);
      alert('Failed to delete character: ' + e.message);
    } finally {
      deleteBtn.disabled = false;
      deleteBtn.textContent = 'Delete Character';
    }
  }

  // Event listeners - Character modal
  document.getElementById('character-modal-close').addEventListener('click', closeCharacterModal);
  document.querySelector('#character-modal .stc-modal__backdrop').addEventListener('click', closeCharacterModal);
  document.getElementById('btn-character-cancel').addEventListener('click', closeCharacterModal);
  document.getElementById('btn-character-save').addEventListener('click', saveCharacter);
  document.getElementById('btn-character-delete').addEventListener('click', deleteCharacter);

  // Character sheet event listeners
  document.getElementById('character-sheet-close').addEventListener('click', closeCharacterSheet);
  document.querySelector('#character-sheet-modal .stc-modal__backdrop').addEventListener('click', closeCharacterSheet);
  document.getElementById('sheet-edit-btn').addEventListener('click', () => {
    if (currentSheetCharacter) {
      const charToEdit = currentSheetCharacter;
      closeCharacterSheet();
      openCharacterModal(charToEdit);
    }
  });

  // Dev Zone toggle
  document.getElementById('dev-zone-toggle').addEventListener('click', () => {
    const content = document.getElementById('dev-zone-content');
    const arrow = document.querySelector('.stc-dev-zone__arrow');
    const isOpen = content.style.display !== 'none';
    content.style.display = isOpen ? 'none' : 'block';
    arrow.textContent = isOpen ? '‚ñº' : '‚ñ≤';
  });

  // Dev zone character token click handler
  document.getElementById('dev-entity-test').addEventListener('click', (e) => {
    if (e.target.classList.contains('character-token')) {
      const charId = e.target.dataset.characterId;
      const character = currentCharacters.find(c => c.id === charId);
      if (character) {
        openCharacterSheet(character);
      }
    }
  });

  // Dev zone test buttons
  document.getElementById('dev-test-overlay').addEventListener('click', () => {
    showAIOverlay('Test AI Overlay', 'This will auto-dismiss in 5 seconds');
    setTimeout(() => hideAIOverlay(), 5000);
  });

  document.getElementById('dev-test-toast-info').addEventListener('click', () => {
    showToast('This is an info toast message', 'info', 5000);
  });

  document.getElementById('dev-test-toast-success').addEventListener('click', () => {
    showToast('This is a success toast message', 'success', 5000);
  });

  document.getElementById('dev-test-toast-checking').addEventListener('click', () => {
    showToast('Checking something...', 'checking', 5000);
  });

  // Event listener - Form submit (prevent default, use button click)
  document.getElementById('character-form').addEventListener('submit', (e) => {
    e.preventDefault();
    saveCharacter();
  });

  // Event listeners - Add character buttons in slots
  document.querySelectorAll('.stc-character-slot__add').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = btn.closest('.stc-character-slot');
      const role = slot.dataset.role;
      openCharacterModal(null, role);
    });
  });

  // Event listener - Add another character button (no role)
  document.getElementById('btn-add-character').addEventListener('click', () => {
    openCharacterModal(null, null);
  });

  // Event listener - AI generate button
  document.getElementById('btn-character-ai').addEventListener('click', generateCharacterWithAI);

  // Event listeners - Re-roll buttons
  document.querySelectorAll('.stc-character-form__reroll').forEach(btn => {
    btn.addEventListener('click', () => rerollCharacterField(btn.dataset.field));
  });

  // Show/hide character form loading state
  function setCharacterFormLoading(loading) {
    const loadingEl = document.getElementById('character-form-loading');
    const fields = document.querySelectorAll('.stc-character-form__field');
    const buttons = document.querySelectorAll('.stc-character-form__actions button');

    loadingEl.style.display = loading ? 'flex' : 'none';
    fields.forEach(f => f.classList.toggle('stc-character-form__field--loading', loading));
    buttons.forEach(b => b.disabled = loading);
  }

  // Generate character with AI
  async function generateCharacterWithAI() {
    if (!currentProject || !currentBraindump) {
      alert('Missing project context.');
      return;
    }

    const storyConcept = currentProject?.story_concept?.concept;
    if (!storyConcept) {
      alert('Generate a story concept first before creating AI characters.');
      return;
    }

    // Check if editing an existing character with data
    const existingId = document.getElementById('character-id').value;
    const existingName = document.getElementById('character-name').value.trim();
    const existingWant = document.getElementById('character-want').value.trim();
    const existingNeed = document.getElementById('character-need').value.trim();

    if (existingId || existingName || existingWant || existingNeed) {
      const confirmed = confirm(
        '‚ö†Ô∏è This will replace ALL fields for this character.\n\n' +
        'If you only want to regenerate specific fields, use the üé≤ buttons next to each field instead.\n\n' +
        'Continue with full character regeneration?'
      );
      if (!confirmed) return;
    }

    setCharacterFormLoading(true);
    showAIOverlay('Generating Character', 'Claude is bringing your character to life...');

    try {
      const role = document.getElementById('character-role').value || null;
      const hydratedGenome = currentProject?.genome ? hydrateGenome(currentProject.genome) : null;

      const response = await fetch('/.netlify/functions/generate-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          braindump: currentBraindump.raw_input,
          genome: hydratedGenome,
          storyConcept: storyConcept,
          existingCharacters: currentCharacters,
          role: role
        })
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Netlify function not available. Run "netlify dev" locally or deploy to Netlify.');
      }

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to generate character');
      }

      // Populate form fields with generated character
      populateCharacterForm(data.character);

    } catch (e) {
      console.error('Character generation error:', e);
      alert('Failed to generate character: ' + e.message);
    } finally {
      setCharacterFormLoading(false);
      hideAIOverlay();
    }
  }

  // Populate form from character object
  function populateCharacterForm(char) {
    document.getElementById('character-name').value = char.name || '';
    document.getElementById('character-want').value = char.want || '';
    document.getElementById('character-need').value = char.need || '';
    document.getElementById('character-arc-type').value = char.arc_type || '';
    document.getElementById('character-arc-desc').value = char.arc_description || '';
    document.getElementById('character-connections').value = char.connections || '';
  }

  // Get current form values as character object
  function getCharacterFormValues() {
    return {
      name: document.getElementById('character-name').value,
      want: document.getElementById('character-want').value,
      need: document.getElementById('character-need').value,
      arc_type: document.getElementById('character-arc-type').value,
      arc_description: document.getElementById('character-arc-desc').value,
      connections: document.getElementById('character-connections').value
    };
  }

  // Re-roll a single character field
  async function rerollCharacterField(fieldName) {
    if (!currentProject || !currentBraindump) {
      alert('Missing project context.');
      return;
    }

    const storyConcept = currentProject?.story_concept?.concept;
    if (!storyConcept) {
      alert('Generate a story concept first.');
      return;
    }

    // Find the re-roll button and field
    const btn = document.querySelector(`.stc-character-form__reroll[data-field="${fieldName}"]`);
    const fieldEl = document.querySelector(`.stc-character-form__field[data-field="${fieldName}"]`);

    // Show loading state on just this field
    btn.classList.add('stc-character-form__reroll--loading');
    btn.disabled = true;
    fieldEl.classList.add('stc-character-form__field--loading');

    try {
      const role = document.getElementById('character-role').value || null;
      const hydratedGenome = currentProject?.genome ? hydrateGenome(currentProject.genome) : null;
      const currentValues = getCharacterFormValues();

      const response = await fetch('/.netlify/functions/generate-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          braindump: currentBraindump.raw_input,
          genome: hydratedGenome,
          storyConcept: storyConcept,
          existingCharacters: currentCharacters,
          role: role,
          currentCharacter: currentValues,
          rerollField: fieldName
        })
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Netlify function not available.');
      }

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to regenerate field');
      }

      // Update just the one field
      const char = data.character;
      const fieldMap = {
        name: 'character-name',
        want: 'character-want',
        need: 'character-need',
        arc_type: 'character-arc-type',
        arc_description: 'character-arc-desc',
        connections: 'character-connections'
      };

      const inputId = fieldMap[fieldName];
      const previousValue = currentValues[fieldName];
      if (inputId && char[fieldName] !== undefined) {
        document.getElementById(inputId).value = char[fieldName];
      }

      // Check for within-character cascade after updating the field
      if (char[fieldName] !== previousValue) {
        checkWithinCharacterCascade(fieldName, previousValue);
      }

    } catch (e) {
      console.error('Field reroll error:', e);
      alert('Failed to regenerate: ' + e.message);
    } finally {
      btn.classList.remove('stc-character-form__reroll--loading');
      btn.disabled = false;
      fieldEl.classList.remove('stc-character-form__field--loading');
    }
  }

  // ========== CASCADE SYSTEM ==========

  let pendingCascadeItems = []; // Stores cascade items for the modal

  // Check within-character cascade after a field change
  async function checkWithinCharacterCascade(changedField, previousValue) {
    const currentValues = getCharacterFormValues();
    const previousCharacter = { ...currentValues, [changedField]: previousValue };

    // Show toast while checking
    const toastId = showToast('Checking character consistency...', 'checking', 0);

    try {
      const response = await fetch('/.netlify/functions/cascade-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          cascadeType: 'within-character',
          character: currentValues,
          previousCharacter: previousCharacter,
          changedField: changedField
        })
      });

      removeToast(toastId);

      if (!response.ok) return;

      const data = await response.json();

      if (data.cascade?.hasImpact && data.cascade.affectedFields?.length > 0) {
        // Show cascade modal with within-character updates
        showCascadeModal('within-character', data.cascade.affectedFields);
      }
    } catch (e) {
      removeToast(toastId);
      console.error('Within-character cascade check failed:', e);
      // Silently fail - cascade is a nice-to-have
    }
  }

  // Check project-wide cascade after saving a character
  async function checkProjectWideCascade(character, previousCharacter) {
    const storyConcept = currentProject?.story_concept?.concept;
    if (!storyConcept) return;

    // Show toast while checking
    const toastId = showToast('Checking for downstream impacts...', 'checking', 0);

    try {
      const response = await fetch('/.netlify/functions/cascade-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          cascadeType: 'project-wide',
          character: character,
          previousCharacter: previousCharacter,
          storyConcept: storyConcept,
          allCharacters: currentCharacters,
          genome: currentProject?.genome ? hydrateGenome(currentProject.genome) : null
        })
      });

      removeToast(toastId);

      if (!response.ok) return;

      const data = await response.json();

      if (data.cascade?.hasImpact) {
        const items = [];

        // Add story concept impact
        if (data.cascade.storyConceptImpact?.needsUpdate) {
          // Extract a meaningful excerpt from the story concept
          const conceptExcerpt = storyConcept.length > 300
            ? storyConcept.substring(0, 300) + '...'
            : storyConcept;

          items.push({
            type: 'story-concept',
            target: 'Story Concept',
            field: 'concept',
            reason: data.cascade.storyConceptImpact.reason,
            currentValue: conceptExcerpt,
            suggestedValue: data.cascade.storyConceptImpact.suggestedRevisions,
            fullConcept: storyConcept
          });
        }

        // Add character impacts
        if (data.cascade.characterImpacts?.length > 0) {
          data.cascade.characterImpacts.forEach(impact => {
            items.push({
              type: 'character',
              characterId: impact.characterId,
              target: impact.characterName,
              field: impact.field,
              reason: impact.reason,
              currentValue: impact.currentValue,
              suggestedValue: impact.suggestedValue
            });
          });
        }

        if (items.length > 0) {
          showCascadeModal('project-wide', items);
        }
      }
    } catch (e) {
      removeToast(toastId);
      console.error('Project-wide cascade check failed:', e);
    }
  }

  // Show the cascade confirmation modal
  function showCascadeModal(cascadeType, items) {
    pendingCascadeItems = items.map((item, index) => ({ ...item, id: index, selected: true }));

    const modal = document.getElementById('cascade-modal');
    const intro = document.getElementById('cascade-intro');
    const itemsContainer = document.getElementById('cascade-items');

    // Set intro text based on type
    if (cascadeType === 'within-character') {
      intro.textContent = 'Your change may affect other fields in this character. Review the suggested updates below.';
    } else {
      intro.textContent = 'Your character change may affect other parts of your story. Review the suggested updates below.';
    }

    // Render items
    itemsContainer.innerHTML = pendingCascadeItems.map(item => `
      <div class="stc-cascade-item" data-cascade-id="${item.id}">
        <div class="stc-cascade-item__header">
          <input type="checkbox" class="stc-cascade-item__checkbox" ${item.selected ? 'checked' : ''} data-cascade-id="${item.id}">
          <span class="stc-cascade-item__title">
            Update <span class="stc-cascade-item__target">${escapeHtml(item.target)}</span> ‚Üí ${escapeHtml(item.field)}
          </span>
        </div>
        <p class="stc-cascade-item__reason">${escapeHtml(item.reason)}</p>
        <div class="stc-cascade-item__diff">
          <div class="stc-cascade-item__old">${escapeHtml(truncate(item.currentValue, 150))}</div>
          <div class="stc-cascade-item__new">${escapeHtml(truncate(item.suggestedValue, 150))}</div>
        </div>
      </div>
    `).join('');

    // Attach checkbox listeners
    itemsContainer.querySelectorAll('.stc-cascade-item__checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        const id = parseInt(e.target.dataset.cascadeId);
        const item = pendingCascadeItems.find(i => i.id === id);
        if (item) item.selected = e.target.checked;
      });
    });

    document.body.style.overflow = 'hidden';
    modal.style.display = 'flex';
  }

  // Close cascade modal
  function closeCascadeModal() {
    document.getElementById('cascade-modal').style.display = 'none';
    document.body.style.overflow = '';
    pendingCascadeItems = [];
  }

  // Apply selected cascade items
  async function applyCascadeItems() {
    const selectedItems = pendingCascadeItems.filter(item => item.selected);

    for (const item of selectedItems) {
      if (item.type === 'within-character' || !item.type) {
        // Update form field
        const fieldMap = {
          name: 'character-name',
          want: 'character-want',
          need: 'character-need',
          arc_type: 'character-arc-type',
          arc_description: 'character-arc-desc',
          connections: 'character-connections'
        };
        const inputId = fieldMap[item.field];
        if (inputId) {
          document.getElementById(inputId).value = item.suggestedValue;
        }
      } else if (item.type === 'character') {
        // Update another character's field
        const char = currentCharacters.find(c => c.id === item.characterId);
        if (char) {
          char[item.field] = item.suggestedValue;
          // Save to database
          await supabase
            .from('characters')
            .update({ [item.field]: item.suggestedValue })
            .eq('id', item.characterId);
        }
      } else if (item.type === 'story-concept') {
        // Show the in-context suggestions banner instead of alert
        showConceptSuggestions(item);
      }
    }

    closeCascadeModal();
    renderAllCharacterSlots(); // Refresh display
  }

  // Show the story concept suggestions banner with diff view
  let pendingConceptSuggestion = null; // Store the current suggestion item

  function showConceptSuggestions(item) {
    pendingConceptSuggestion = item;

    const banner = document.getElementById('concept-suggestions');
    const reasonEl = document.getElementById('suggestions-reason');
    const currentEl = document.getElementById('suggestions-current');
    const proposedEl = document.getElementById('suggestions-proposed');

    // Populate the banner
    reasonEl.textContent = item.reason || 'The AI detected that your story concept may need updates based on recent character changes.';
    currentEl.textContent = item.currentValue || '(No current concept)';
    proposedEl.value = item.suggestedValue || '(No specific suggestions)';

    // Show the banner
    banner.style.display = 'block';

    // Scroll to the story concept section
    const conceptSection = document.getElementById('concept-section');
    if (conceptSection) {
      conceptSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  // Hide the story concept suggestions banner
  function hideConceptSuggestions() {
    document.getElementById('concept-suggestions').style.display = 'none';
    pendingConceptSuggestion = null;
  }

  // Apply the suggested changes to the story concept
  async function applyConceptSuggestions() {
    if (!pendingConceptSuggestion || !currentProject) return;

    const applyBtn = document.getElementById('btn-suggestions-apply');
    const btnText = applyBtn.querySelector('.btn-text');
    const btnLoading = applyBtn.querySelector('.btn-loading');

    // Get the (possibly edited) suggestions from the textarea
    const editedSuggestions = document.getElementById('suggestions-proposed').value;
    const currentConcept = currentProject?.story_concept?.concept || '';

    // Show loading state
    btnText.style.display = 'none';
    btnLoading.style.display = 'inline-flex';
    applyBtn.disabled = true;

    try {
      // Call the refine-section function to apply the changes
      // Format: sectionName, allSections (array of {name, content}), direction, genome, braindump
      const response = await fetch('/.netlify/functions/refine-section', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sectionName: 'Story Concept',
          allSections: [{ name: 'Story Concept', content: currentConcept }],
          direction: `Apply these specific changes based on character updates:\n\n${editedSuggestions}\n\nReason for changes: ${pendingConceptSuggestion.reason}`,
          braindump: currentProject.braindump,
          genome: currentProject.genome ? hydrateGenome(currentProject.genome) : null
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to apply changes');
      }

      const data = await response.json();
      const revisedConcept = data.revisedSection;

      // Update the project in the database
      const { error } = await supabase
        .from('projects')
        .update({
          story_concept: {
            ...currentProject.story_concept,
            concept: revisedConcept
          }
        })
        .eq('id', currentProject.id);

      if (error) throw error;

      // Update local state
      currentProject.story_concept.concept = revisedConcept;

      // Update the UI using the same rendering as the rest of the app
      currentSections = parseConcept(revisedConcept);
      document.getElementById('concept-content').innerHTML = currentSections.map((section, i) => renderSection(section, i)).join('');

      // Also update the combined view
      document.getElementById('concept-combined-text').textContent = formatConceptForCopy();

      // Show success toast
      showToast('Story concept updated successfully!', 'success', 3000);

      // Hide the suggestions banner
      hideConceptSuggestions();

    } catch (e) {
      console.error('Failed to apply concept suggestions:', e);
      showToast('Failed to apply changes: ' + e.message, 'info', 5000);
    } finally {
      // Reset button state
      btnText.style.display = 'inline';
      btnLoading.style.display = 'none';
      applyBtn.disabled = false;
    }
  }

  // Event listeners - Cascade modal
  document.getElementById('cascade-modal-close').addEventListener('click', closeCascadeModal);
  document.getElementById('btn-cascade-skip').addEventListener('click', closeCascadeModal);
  document.getElementById('btn-cascade-apply').addEventListener('click', applyCascadeItems);

  // Close cascade modal on backdrop click
  document.querySelector('#cascade-modal .stc-modal__backdrop').addEventListener('click', closeCascadeModal);

  // Close suggestions banner
  document.getElementById('btn-close-suggestions').addEventListener('click', hideConceptSuggestions);
  document.getElementById('btn-suggestions-dismiss').addEventListener('click', hideConceptSuggestions);
  document.getElementById('btn-suggestions-apply').addEventListener('click', applyConceptSuggestions);

  diveIntoNew.addEventListener('click', (e) => {
    e.preventDefault();
    if (currentBraindump) {
      showDiveView(currentBraindump, currentProject);
    }
  });

  // Auth state change listener
  supabase.auth.onAuthStateChange((event, session) => {
    console.log('[Auth] State changed:', event, session?.user?.email);
    updateAuthUI(session?.user || null);
  });

  // Init - check for existing session
  async function init() {
    const { data: { session } } = await supabase.auth.getSession();
    updateAuthUI(session?.user || null);

    // Hide loading screen once app is ready
    hideLoadingScreen();
  }

  // Hide the loading screen with a smooth transition
  function hideLoadingScreen() {
    const loadingScreen = document.getElementById('stc-loading');
    if (loadingScreen) {
      // Small delay to ensure styles are applied
      requestAnimationFrame(() => {
        loadingScreen.classList.add('loaded');
        // Remove from DOM after transition
        setTimeout(() => loadingScreen.remove(), 500);
      });
    }
  }

  // Also hide on window load as fallback (in case init fails)
  window.addEventListener('load', () => {
    setTimeout(hideLoadingScreen, 100);
  });

  init();
</script>

<style>
  /* ========== GLOBAL STC OVERRIDES ========== */
  #stc-app {
    color: var(--color-text-primary, #2C2416);
  }

  #stc-app input::placeholder,
  #stc-app textarea::placeholder {
    color: var(--color-text-muted, #8B7D6B);
    opacity: 0.7;
  }

  .stc-view {
    min-height: 60vh;
  }

  /* ========== AUTH VIEW ========== */
  .stc-auth__container {
    max-width: 500px;
    margin: 0 auto;
    padding: var(--spacing-xxl) var(--spacing-md);
    text-align: center;
  }

  .stc-auth__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 2.25rem;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-md);
  }

  .stc-auth__subtitle {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-lg);
    color: var(--color-text-secondary, #5C4D3C);
    margin-bottom: var(--spacing-xl);
    line-height: 1.6;
  }

  .button--google {
    display: inline-flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-md) var(--spacing-xl);
    font-size: var(--font-size-lg);
    font-weight: 500;
    color: #333;
    background: #fff;
    border: 2px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .button--google:hover:not(:disabled) {
    background: #f8f8f8;
    border-color: #aaa;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  .button--google:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .google-icon {
    flex-shrink: 0;
  }

  /* ========== USER BAR ========== */
  .stc-user-bar {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: var(--spacing-md);
    padding: var(--spacing-sm) var(--spacing-lg);
    background: var(--color-background-tertiary, #EDE4D9);
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-user-bar__email {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary, #5C4D3C);
  }

  /* ========== LIST VIEW ========== */
  .stc-test-flow__container {
    max-width: 700px;
    margin: 0 auto;
    padding: var(--spacing-xl) var(--spacing-md);
    text-align: center;
  }

  .stc-test-flow__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 2rem;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-sm);
  }

  .stc-test-flow__subtitle {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-lg);
  }

  .stc-test-flow__textarea {
    width: 100%;
    min-height: 200px;
    padding: var(--spacing-lg);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-lg);
    line-height: 1.7;
    color: var(--color-text-primary, #2C2416);
    background: var(--color-background-card, #FFFCF8);
    border: 2px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    resize: vertical;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .stc-test-flow__textarea:focus {
    outline: none;
    border-color: var(--color-accent-primary, #B85C38);
    box-shadow: 0 0 0 4px rgba(184, 92, 56, 0.1);
  }

  .stc-test-flow__textarea::placeholder {
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  .stc-test-flow__button {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md) var(--spacing-xl);
    font-size: var(--font-size-lg);
  }

  .stc-test-flow__button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .stc-test-flow__result,
  .stc-test-flow__error {
    margin-top: var(--spacing-xl);
    padding: var(--spacing-lg);
    border-radius: var(--radius-md);
    text-align: left;
  }

  .stc-test-flow__result {
    background: #D4EDDA;
    border: 1px solid #28A745;
  }

  .stc-test-flow__result h3 {
    font-family: 'Lora', Georgia, serif;
    color: #155724;
    margin-bottom: var(--spacing-sm);
  }

  .stc-test-flow__result p {
    color: #155724;
  }

  .stc-test-flow__result a {
    color: #155724;
    font-weight: 600;
  }

  .stc-test-flow__error {
    background: #F8D7DA;
    border: 1px solid #DC3545;
  }

  .stc-test-flow__error h3 {
    font-family: 'Lora', Georgia, serif;
    color: #721C24;
    margin-bottom: var(--spacing-sm);
  }

  .stc-test-flow__error p {
    font-family: 'Source Sans 3', sans-serif;
    color: #721C24;
  }

  /* Table */
  .stc-test-flow__existing {
    margin-top: var(--spacing-xxl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
    text-align: left;
  }

  .stc-test-flow__existing h3 {
    font-family: 'Lora', Georgia, serif;
    font-size: var(--font-size-lg);
    color: var(--color-text-secondary, #5C4D3C);
    margin-bottom: var(--spacing-md);
  }

  #braindumps-table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
  }

  #braindumps-table th {
    text-align: left;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--color-background-tertiary, #EDE4D9);
    color: var(--color-text-secondary, #5C4D3C);
    font-weight: 600;
    border-bottom: 2px solid var(--color-border-default, #D9CFC2);
  }

  #braindumps-table td {
    padding: var(--spacing-sm) var(--spacing-md);
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
    vertical-align: middle;
  }

  #braindumps-table .timestamp {
    white-space: nowrap;
    color: var(--color-text-muted, #8B7D6B);
    width: 140px;
  }

  #braindumps-table .content {
    color: var(--color-text-primary, #2C2416);
  }

  #braindumps-table .action {
    width: 100px;
    text-align: right;
  }

  #braindumps-table .loading,
  #braindumps-table .empty {
    text-align: center;
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    padding: var(--spacing-lg);
  }

  #braindumps-table .error {
    text-align: center;
    color: #DC3545;
    padding: var(--spacing-lg);
  }

  #braindumps-table tr:hover td {
    background: var(--color-background-secondary, #F5EEE6);
  }

  .button--small {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: var(--font-size-xs);
  }

  /* ========== DIVE VIEW ========== */
  .stc-dive__container {
    /* Width controlled by .stc-main and .stc-narrow */
    padding: var(--spacing-xl) 0;
  }

  .stc-dive__back {
    margin-bottom: var(--spacing-lg);
  }

  .stc-dive__header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: var(--spacing-lg);
    padding-bottom: var(--spacing-md);
    border-bottom: 2px solid var(--color-accent-primary, #B85C38);
  }

  .stc-dive__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.75rem;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
  }

  .stc-dive__timestamp {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
  }

  /* ========== BRAINDUMP ACCORDION ========== */
  .stc-braindump-accordion {
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-xl);
    overflow: hidden;
  }

  .stc-braindump-accordion__toggle {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    padding: var(--spacing-md) var(--spacing-lg);
    background: var(--color-background-secondary, #F5EEE6);
    border: none;
    cursor: pointer;
    text-align: left;
    transition: background 0.15s ease;
  }

  .stc-braindump-accordion__toggle:hover {
    background: var(--color-background-tertiary, #EDE6DC);
  }

  .stc-braindump-accordion__header {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-shrink: 0;
  }

  .stc-braindump-accordion__header .stc-dive__title {
    font-size: 1.25rem;
    margin: 0;
  }

  .stc-braindump-accordion__preview {
    flex: 1;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-style: italic;
  }

  .stc-braindump-accordion__chevron {
    flex-shrink: 0;
    color: var(--color-text-muted, #8B7D6B);
    transition: transform 0.2s ease;
  }

  .stc-braindump-accordion--expanded .stc-braindump-accordion__chevron {
    transform: rotate(180deg);
  }

  .stc-braindump-accordion__body {
    display: none;
    padding: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-braindump-accordion--expanded .stc-braindump-accordion__body {
    display: block;
  }

  .stc-braindump-accordion__body .stc-dive__text {
    margin-bottom: var(--spacing-md);
    border: none;
    padding: 0;
    background: transparent;
  }

  .stc-braindump-accordion__body .stc-dive__content {
    margin-bottom: 0;
  }

  .stc-dive__content {
    margin-bottom: var(--spacing-xl);
  }

  .stc-dive__text {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-lg);
    line-height: 1.8;
    color: var(--color-text-primary, #2C2416);
    background: var(--color-background-card, #FFFCF8);
    padding: var(--spacing-lg);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border-default, #D9CFC2);
    white-space: pre-wrap;
    margin-bottom: var(--spacing-md);
  }

  .stc-dive__edit {
    display: inline-block;
  }

  .stc-dive__textarea {
    width: 100%;
    min-height: 300px;
    padding: var(--spacing-lg);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-lg);
    line-height: 1.8;
    color: var(--color-text-primary, #2C2416);
    background: var(--color-background-card, #FFFCF8);
    border: 2px solid var(--color-accent-primary, #B85C38);
    border-radius: var(--radius-md);
    resize: vertical;
  }

  .stc-dive__textarea:focus {
    outline: none;
    box-shadow: 0 0 0 4px rgba(184, 92, 56, 0.1);
  }

  .stc-dive__actions {
    display: flex;
    gap: var(--spacing-md);
    margin-top: var(--spacing-md);
  }

  /* ========== BRIEF SECTION ========== */
  .stc-brief {
    margin-top: var(--spacing-xxl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-brief__title-row {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
  }

  .stc-brief__title-regen {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 0;
    background: transparent;
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    color: var(--color-text-muted, #8B7D6B);
    cursor: pointer;
    transition: all 0.15s ease;
    flex-shrink: 0;
  }

  .stc-brief__title-regen:hover {
    background: var(--color-background-secondary, #FAF7F2);
    border-color: var(--color-accent-primary, #7C5E4A);
    color: var(--color-accent-primary, #7C5E4A);
  }

  .stc-brief__title-regen:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .stc-brief__title-regen--loading svg {
    animation: spin 1s linear infinite;
  }

  .stc-brief__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
    padding: 4px 8px;
    margin-left: -8px;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
    transition: border-color 0.15s ease, background 0.15s ease;
    outline: none;
    cursor: text;
  }

  .stc-brief__title:hover {
    background: var(--color-background-secondary, #FAF7F2);
  }

  .stc-brief__title:focus {
    border-color: var(--color-accent-primary, #B85C38);
    background: white;
  }

  .stc-brief__title--generating {
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  /* Project title in list view */
  .title-cell {
    font-weight: 600;
  }

  .project-title {
    display: inline-block;
    padding: 2px 6px;
    margin-left: -6px;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    cursor: text;
    outline: none;
    transition: border-color 0.15s ease, background 0.15s ease;
  }

  .project-title:hover {
    background: var(--color-background-secondary, #FAF7F2);
  }

  .project-title:focus {
    border-color: var(--color-accent-primary, #B85C38);
    background: white;
  }

  .project-title--generating {
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    font-weight: 400;
  }

  .stc-brief__heading {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.5rem;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-xs);
  }

  .stc-brief__note {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-lg);
  }

  .stc-brief__grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--spacing-md);
  }

  @media (min-width: 600px) {
    .stc-brief__grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  .stc-brief__item {
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
  }

  .stc-brief__label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-accent-primary, #B85C38);
    margin-bottom: var(--spacing-xs);
  }

  .stc-brief__content {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.5;
    margin: 0;
  }

  .stc-brief__placeholder {
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  .stc-brief__loading {
    color: var(--color-accent-primary, #7C5E4A);
    font-style: italic;
  }

  .stc-brief__loading::after {
    content: '';
    animation: briefPulse 1.5s infinite;
  }

  @keyframes briefPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .stc-brief__header {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
  }

  .stc-brief__status {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    transition: opacity 0.2s ease;
  }

  .stc-brief__status--success {
    color: #28A745;
  }

  .stc-brief__status--error {
    color: #DC3545;
  }

  .stc-brief__empty {
    text-align: center;
    padding: var(--spacing-lg);
    background: var(--color-background-secondary, #FAF7F2);
    border-radius: var(--radius-md);
  }

  .stc-brief__loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: var(--spacing-xl);
    text-align: center;
    background: var(--color-background-secondary, #FAF7F2);
    border-radius: var(--radius-md);
  }

  .stc-brief__loading-state .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--color-border-default, #D9CFC2);
    border-top-color: var(--color-accent-primary, #B85C38);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: var(--spacing-md);
  }

  .stc-brief__item-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--spacing-xs);
  }

  .stc-brief__item-edit {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    padding: 0;
    background: transparent;
    border: none;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s ease;
  }

  .stc-brief__item-edit:hover {
    opacity: 1;
  }

  .stc-brief__item-edit svg {
    width: 14px;
    height: 14px;
  }

  .stc-brief__textarea {
    width: 100%;
    min-height: 80px;
    padding: var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    line-height: 1.5;
    border: 1px solid var(--color-accent-primary, #B85C38);
    border-radius: var(--radius-sm);
    resize: vertical;
    background: white;
  }

  .stc-brief__textarea:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(184, 92, 56, 0.2);
  }

  .stc-brief__item-actions {
    display: flex;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-sm);
    justify-content: flex-end;
  }

  .stc-brief__item-actions .button {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: var(--font-size-xs);
  }

  .stc-brief__actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-brief__locked {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
    color: #28A745;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
  }

  .stc-brief__locked-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background: #28A745;
    color: white;
    border-radius: 50%;
    font-size: 12px;
    font-weight: bold;
  }

  .stc-brief__locked-text {
    flex: 1;
  }

  /* ========== SPINE BUILDER ========== */
  .stc-spine {
    margin-top: var(--spacing-xxl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-spine__heading {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.5rem;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-xs);
  }

  .stc-spine__note {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-xl);
  }

  .stc-spine__actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    margin-top: var(--spacing-xl);
    padding-top: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-spine__status {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    transition: opacity 0.2s ease;
  }

  .stc-spine__status--success {
    color: #28A745;
  }

  .stc-spine__status--error {
    color: #DC3545;
  }

  /* Vertical spine layout */
  .stc-spine__vertebrae {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  /* Individual vertebra row - full width, stacking vertically */
  .stc-vertebra-row {
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-bottom: none;
    padding: var(--spacing-lg) var(--spacing-xl);
    position: relative;
  }

  .stc-vertebra-row:first-child {
    border-radius: var(--radius-md) var(--radius-md) 0 0;
  }

  .stc-vertebra-row:last-child {
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: 0 0 var(--radius-md) var(--radius-md);
  }

  /* Subtle separator between vertebrae */
  .stc-vertebra-row + .stc-vertebra-row::before {
    content: '';
    position: absolute;
    top: 0;
    left: var(--spacing-xl);
    right: var(--spacing-xl);
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--color-border-default, #D9CFC2), transparent);
  }

  .stc-vertebra-row__header {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-md);
  }

  .stc-vertebra-row__number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: var(--color-accent-primary, #B85C38);
    color: #fff;
    font-family: 'Lora', Georgia, serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .stc-vertebra-row__header-text {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .stc-vertebra-row__label {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
  }

  .stc-vertebra-row__description {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  .stc-vertebra-row__body {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    gap: var(--spacing-md);
  }

  .stc-vertebra-row__tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-xs);
    flex: 1;
    min-height: 36px;
    align-items: center;
  }

  .stc-vertebra-row__combobox {
    flex-shrink: 0;
    min-width: 200px;
  }

  /* Combined row (Tone & Humor) with three columns */
  .stc-vertebra-row__body--three-col {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--spacing-lg);
  }

  @media (min-width: 768px) {
    .stc-vertebra-row__body--three-col {
      grid-template-columns: 1fr auto 1fr;
    }
  }

  .stc-vertebra-col {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .stc-vertebra-col__label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-vertebra-col__description {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    margin-top: -4px;
  }

  .stc-vertebra-col__tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-xs);
    min-height: 32px;
    align-items: center;
  }

  .stc-vertebra-col__combobox {
    width: 100%;
  }

  /* Humor role column - left aligned like humor style */
  .stc-vertebra-col--humor-role {
    align-items: flex-start;
    justify-content: flex-start;
  }

  .stc-vertebra-col--humor-role .stc-combobox {
    min-width: 160px;
  }

  /* Humor style disabled state */
  .stc-vertebra-col--humor-style.stc-vertebra--disabled {
    opacity: 0.4;
  }

  /* Empty state text */
  .stc-vertebra__empty,
  .stc-vertebra-row__empty {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  /* Tags */
  .stc-tag {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: var(--color-accent-primary, #B85C38);
    color: #fff;
    border-radius: var(--radius-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 500;
  }

  .stc-tag__text {
    line-height: 1;
  }

  .stc-tag__remove {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    padding: 0;
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 50%;
    color: #fff;
    font-size: 14px;
    line-height: 1;
    cursor: pointer;
    transition: background 0.15s ease;
  }

  .stc-tag__remove:hover {
    background: rgba(255, 255, 255, 0.4);
  }

  /* ========== CUSTOM COMBOBOX ========== */
  .stc-combobox {
    position: relative;
    width: 100%;
  }

  .stc-combobox__input-wrap {
    position: relative;
    display: flex;
    align-items: center;
  }

  .stc-combobox__input {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-xl) var(--spacing-sm) var(--spacing-md);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    background: var(--color-background-primary, #FAF6F1);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    cursor: text;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
  }

  .stc-combobox__input::placeholder {
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-combobox__input:focus {
    outline: none;
    border-color: var(--color-accent-primary, #B85C38);
    box-shadow: 0 0 0 3px rgba(184, 92, 56, 0.1);
  }

  .stc-combobox__arrow {
    position: absolute;
    right: var(--spacing-sm);
    color: var(--color-text-muted, #8B7D6B);
    font-size: 12px;
    pointer-events: auto;
    cursor: pointer;
    padding: 4px;
    transition: transform 0.15s ease;
  }

  .stc-combobox--open .stc-combobox__arrow {
    transform: rotate(180deg);
  }

  .stc-combobox__dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin: 0;
    padding: 0;
    list-style: none;
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-top: none;
    border-radius: 0 0 var(--radius-sm) var(--radius-sm);
    box-shadow: 0 4px 12px rgba(44, 36, 22, 0.1);
    max-height: 240px;
    overflow-y: auto;
    z-index: 100;
    display: none;
  }

  .stc-combobox--open .stc-combobox__dropdown {
    display: block;
  }

  .stc-combobox--open .stc-combobox__input {
    border-radius: var(--radius-sm) var(--radius-sm) 0 0;
  }

  .stc-combobox__option {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    transition: background 0.1s ease;
    border-bottom: 1px solid var(--color-border-light, #EDE4D9);
  }

  .stc-combobox__option:last-child {
    border-bottom: none;
  }

  .stc-combobox__option:hover {
    background: var(--color-background-secondary, #F5EEE6);
  }

  .stc-combobox__option--highlighted {
    background: var(--color-background-tertiary, #EDE4D9);
  }

  .stc-combobox__option--highlighted:hover {
    background: var(--color-background-tertiary, #EDE4D9);
  }

  .stc-combobox__option-name {
    display: block;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 500;
    color: var(--color-text-primary, #2C2416);
  }

  .stc-combobox__option-name mark {
    background: rgba(184, 92, 56, 0.2);
    color: inherit;
    padding: 0 2px;
    border-radius: 2px;
  }

  .stc-combobox__option-desc {
    display: block;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    margin-top: 2px;
  }

  .stc-combobox__empty {
    padding: var(--spacing-md);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    text-align: center;
  }

  /* Disabled state */
  .stc-combobox--disabled {
    opacity: 0.5;
  }

  .stc-combobox--disabled .stc-combobox__input {
    cursor: not-allowed;
    background: var(--color-background-tertiary, #EDE4D9);
  }

  .stc-combobox--disabled .stc-combobox__arrow {
    cursor: not-allowed;
  }

  /* Scrollbar styling for dropdown */
  .stc-combobox__dropdown::-webkit-scrollbar {
    width: 8px;
  }

  .stc-combobox__dropdown::-webkit-scrollbar-track {
    background: var(--color-background-secondary, #F5EEE6);
    border-radius: 0 0 var(--radius-sm) 0;
  }

  .stc-combobox__dropdown::-webkit-scrollbar-thumb {
    background: var(--color-border-default, #D9CFC2);
    border-radius: 4px;
  }

  .stc-combobox__dropdown::-webkit-scrollbar-thumb:hover {
    background: var(--color-text-muted, #8B7D6B);
  }

  /* ========== STORY CONCEPT SECTION ========== */
  .stc-concept {
    margin-top: var(--spacing-xxl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-concept__header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    margin-bottom: var(--spacing-sm);
  }

  .stc-concept__heading {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.5rem;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
  }

  .stc-concept__note {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    margin: 0 0 var(--spacing-md) 0;
  }

  /* AI Suggestions Banner */
  .stc-concept__suggestions {
    background: linear-gradient(135deg, #FFF8E7 0%, #FFF3D6 100%);
    border: 1px solid #E8D5A3;
    border-left: 4px solid #D4A853;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    animation: slideDown 0.3s ease-out;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .stc-concept__suggestions-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
    color: #8B6914;
    font-weight: 600;
    font-size: var(--font-size-sm);
  }

  .stc-concept__suggestions-header svg {
    stroke: #D4A853;
    flex-shrink: 0;
  }

  .stc-concept__suggestions-close {
    margin-left: auto;
    background: none;
    border: none;
    font-size: 1.25rem;
    color: #8B6914;
    cursor: pointer;
    padding: 0 var(--spacing-xs);
    line-height: 1;
    opacity: 0.7;
    transition: opacity 0.2s;
  }

  .stc-concept__suggestions-close:hover {
    opacity: 1;
  }

  .stc-concept__suggestions-content {
    font-family: 'Source Sans 3', sans-serif;
  }

  .stc-concept__suggestions-reason {
    font-size: var(--font-size-sm);
    color: #5D4A1F;
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-sm);
    background: rgba(255, 255, 255, 0.5);
    border-radius: var(--radius-sm);
  }

  .stc-concept__suggestions-diff {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--spacing-md);
  }

  .stc-concept__suggestions-old,
  .stc-concept__suggestions-new {
    background: white;
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    border: 1px solid #E8D5A3;
  }

  .stc-concept__suggestions-old {
    border-left: 3px solid #C9A87C;
  }

  .stc-concept__suggestions-new {
    border-left: 3px solid #7BA05B;
  }

  .stc-concept__suggestions-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-xs);
    font-weight: 600;
  }

  .stc-concept__suggestions-text {
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.5;
    max-height: 150px;
    overflow-y: auto;
    white-space: pre-wrap;
  }

  .stc-concept__suggestions-textarea {
    width: 100%;
    min-height: 120px;
    padding: var(--spacing-sm);
    border: 1px solid #E8D5A3;
    border-radius: var(--radius-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.5;
    resize: vertical;
    background: white;
  }

  .stc-concept__suggestions-textarea:focus {
    outline: none;
    border-color: #D4A853;
    box-shadow: 0 0 0 2px rgba(212, 168, 83, 0.2);
  }

  .stc-concept__suggestions-actions {
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-md);
    padding-top: var(--spacing-md);
    border-top: 1px solid #E8D5A3;
  }

  .stc-concept__suggestions-spinner {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: var(--spacing-xs);
  }

  #btn-suggestions-apply .btn-loading {
    display: inline-flex;
    align-items: center;
  }

  /* Loading state */
  .stc-concept__loading {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    padding: var(--spacing-lg);
    background: var(--color-background-secondary, #F5EEE6);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-md);
  }

  .stc-concept__spinner {
    width: 24px;
    height: 24px;
    border: 3px solid var(--color-border-default, #D9CFC2);
    border-top-color: var(--color-accent-primary, #B85C38);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .stc-concept__loading-text {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
  }

  /* Result display */
  .stc-concept__result {
    margin-top: var(--spacing-md);
  }

  /* Genome DNA display */
  .stc-concept__genome {
    margin-bottom: var(--spacing-md);
  }

  .stc-concept__genome-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: var(--spacing-xs);
  }

  .stc-concept__genome-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-concept__genome-copy {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 22px;
    height: 22px;
    background: transparent;
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    color: var(--color-text-muted, #8B7D6B);
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .stc-concept__genome-copy:hover {
    background: var(--color-background-secondary, #F5EEE6);
    border-color: var(--color-accent-primary, #7C5E4A);
    color: var(--color-accent-primary, #7C5E4A);
  }

  .stc-concept__genome-copy--success {
    background: #E8F5E9;
    border-color: #28A745;
    color: #28A745;
  }

  .stc-concept__genome-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .stc-concept__genome-tag {
    display: inline-block;
    padding: 4px 10px;
    border-radius: var(--radius-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 500;
    color: #fff;
  }

  .stc-concept__genome-tag--genre { background: #7C5E4A; }
  .stc-concept__genome-tag--archetype { background: #5C7C6A; }
  .stc-concept__genome-tag--theme { background: #6A5C7C; }
  .stc-concept__genome-tag--tone { background: #7C6A5C; }
  .stc-concept__genome-tag--stakes { background: #8B5C5C; }
  .stc-concept__genome-tag--humor { background: #5C768B; }

  /* Ready state - genome applied, ready to generate */
  .stc-concept__ready {
    text-align: center;
    padding: var(--spacing-xl) var(--spacing-lg);
    background: var(--color-background-secondary, #FAF7F2);
    border: 1px dashed var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    margin-top: var(--spacing-md);
  }

  .stc-concept__ready-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-md);
  }

  .stc-concept__ready-genome {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin-bottom: var(--spacing-xl);
  }

  .stc-concept__pill {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 20px;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    background: white;
    border: 1px solid var(--color-border-default, #D9CFC2);
    color: var(--color-text-primary, #2C2416);
  }

  .stc-concept__pill-label {
    font-weight: 600;
    color: var(--color-accent-primary, #7C5E4A);
  }

  .stc-concept__cta {
    font-size: var(--font-size-lg);
    padding: var(--spacing-md) var(--spacing-xxl);
  }

  .button--large {
    font-size: var(--font-size-lg);
    padding: var(--spacing-md) var(--spacing-xxl);
  }

  .stc-concept__content {
    /* Container for section cards - no background since sections have their own */
    margin-bottom: var(--spacing-md);
  }

  .stc-concept__content h3.stc-concept__head {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.25rem;
    color: var(--color-accent-primary, #B85C38);
    margin: var(--spacing-lg) 0 var(--spacing-sm) 0;
  }

  .stc-concept__content h3.stc-concept__head:first-child {
    margin-top: 0;
  }

  .stc-concept__content h4.stc-concept__subhead {
    font-family: 'Source Sans 3', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    margin: var(--spacing-md) 0 var(--spacing-xs) 0;
  }

  .stc-concept__content p {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.6;
    color: var(--color-text-primary, #2C2416);
    margin: 0 0 var(--spacing-sm) 0;
  }

  .stc-concept__content p:last-child {
    margin-bottom: 0;
  }

  .stc-concept__content strong {
    color: var(--color-text-primary, #2C2416);
    font-weight: 600;
  }

  .stc-concept__content em {
    font-style: italic;
  }

  /* Actions row */
  .stc-concept__actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    flex-wrap: wrap;
  }

  .stc-concept__status {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    transition: opacity 0.2s ease;
  }

  .stc-concept__status--success {
    color: #28A745;
  }

  .stc-concept__status--error {
    color: #DC3545;
  }

  /* Error display */
  .stc-concept__error {
    padding: var(--spacing-md);
    background: #FDF2F2;
    border: 1px solid #F5C6CB;
    border-radius: var(--radius-md);
    margin-top: var(--spacing-md);
  }

  .stc-concept__error-title {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    font-weight: 600;
    color: #721C24;
    margin: 0 0 var(--spacing-xs) 0;
  }

  .stc-concept__error-message {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #721C24;
    margin: 0;
  }

  /* ========== VIEW TOGGLE ========== */
  .stc-concept__view-toggle {
    display: flex;
    gap: 0;
    margin-bottom: var(--spacing-md);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    overflow: hidden;
    width: fit-content;
  }

  .stc-concept__view-btn {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 500;
    color: var(--color-text-secondary, #5C5346);
    background: var(--color-background-card, #FFFCF8);
    border: none;
    padding: var(--spacing-xs) var(--spacing-md);
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .stc-concept__view-btn:hover {
    background: var(--color-background-secondary, #F5EEE6);
  }

  .stc-concept__view-btn--active {
    background: var(--color-accent-primary, #7C5E4A);
    color: white;
  }

  .stc-concept__view-btn--active:hover {
    background: var(--color-accent-primary, #7C5E4A);
  }

  /* ========== COMBINED VIEW ========== */
  .stc-concept__combined {
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    overflow: hidden;
  }

  .stc-concept__combined-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--color-background-secondary, #F5EEE6);
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-concept__combined-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .stc-concept__copy-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 500;
    color: var(--color-text-secondary, #5C5346);
    background: transparent;
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    padding: 4px 10px;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .stc-concept__copy-btn:hover {
    background: var(--color-background-card, #FFFCF8);
    border-color: var(--color-accent-primary, #7C5E4A);
    color: var(--color-accent-primary, #7C5E4A);
  }

  .stc-concept__copy-btn--success {
    background: #E8F5E9;
    border-color: #28A745;
    color: #28A745;
  }

  .stc-concept__copy-btn svg {
    flex-shrink: 0;
  }

  .stc-concept__combined-text {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.7;
    color: var(--color-text-primary, #2C2416);
    padding: var(--spacing-md);
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 600px;
    overflow-y: auto;
  }

  /* ========== SECTION EDITOR ========== */
  .stc-section {
    background: var(--color-background-card, #FFFCF8);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-md);
    overflow: hidden;
  }

  .stc-section__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--color-background-secondary, #F5EEE6);
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-section__title {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .stc-section__actions {
    display: flex;
    gap: 4px;
  }

  .stc-section__btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 0;
    background: transparent;
    border: 1px solid transparent;
    border-radius: var(--radius-sm);
    color: var(--color-text-muted, #8B7D6B);
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .stc-section__btn:hover {
    background: var(--color-background-card, #FFFCF8);
    border-color: var(--color-border-default, #D9CFC2);
    color: var(--color-text-primary, #2C2416);
  }

  .stc-section__btn--refine:hover {
    color: var(--color-accent-primary, #B85C38);
  }

  .stc-section__display {
    padding: var(--spacing-md);
    color: #2C2416;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.6;
  }

  .stc-section__display p {
    margin: 0 0 var(--spacing-sm) 0;
  }

  .stc-section__display p:last-child {
    margin-bottom: 0;
  }

  /* Character entity tokens */
  .character-token {
    background: rgba(184, 92, 56, 0.15);
    color: #8B4513;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-weight: 500;
    transition: background 0.15s ease, color 0.15s ease;
  }

  .character-token:hover {
    background: rgba(184, 92, 56, 0.3);
    color: #6B3410;
  }

  /* Edit mode */
  .stc-section__edit-mode,
  .stc-section__refine-mode {
    padding: var(--spacing-md);
  }

  .stc-section__textarea,
  .stc-section__direction {
    width: 100%;
    min-height: 120px;
    padding: var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.6;
    color: var(--color-text-primary, #2C2416);
    background: var(--color-background-primary, #FAF6F1);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    resize: vertical;
  }

  .stc-section__textarea:focus,
  .stc-section__direction:focus {
    outline: none;
    border-color: var(--color-accent-primary, #B85C38);
    box-shadow: 0 0 0 3px rgba(184, 92, 56, 0.1);
  }

  .stc-section__direction {
    min-height: 80px;
  }

  .stc-section__edit-actions,
  .stc-section__refine-actions,
  .stc-section__suggestion-actions {
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-sm);
  }

  /* Suggestion display */
  .stc-section__suggestion {
    padding: var(--spacing-md);
    background: #F0F7F4;
  }

  .stc-section__suggestion-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #2D6A4F;
    margin-bottom: var(--spacing-xs);
  }

  .stc-section__suggestion-content {
    padding: var(--spacing-md);
    background: #fff;
    border: 1px solid #B7E4C7;
    border-radius: var(--radius-sm);
    color: #2C2416;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.6;
  }

  .stc-section__suggestion-content p {
    margin: 0 0 var(--spacing-sm) 0;
  }

  .stc-section__suggestion-content p:last-child {
    margin-bottom: 0;
  }

  /* Affected sections warning */
  .stc-section__affected {
    margin-top: var(--spacing-md);
    padding: var(--spacing-md);
    background: #FFF8E6;
    border: 1px solid #F0D58C;
    border-radius: var(--radius-sm);
  }

  .stc-section__affected-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: #8B6914;
    margin-bottom: var(--spacing-sm);
  }

  .stc-affected-item {
    background: #fff;
    border: 1px solid #E8D9A8;
    border-radius: var(--radius-sm);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
  }

  .stc-affected-item:last-child {
    margin-bottom: 0;
  }

  .stc-affected-item--applied {
    opacity: 0.6;
  }

  .stc-affected-item__header {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-xs);
  }

  .stc-affected-item__reason {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #8B6914;
    font-style: italic;
    margin-bottom: var(--spacing-sm);
  }

  .stc-affected-item__fix {
    background: var(--color-background-secondary, #F5EEE6);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
  }

  .stc-affected-item__fix-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-xs);
  }

  .stc-affected-item__fix-content {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.5;
  }

  .stc-affected-item__fix-content p {
    margin: 0;
  }

  .stc-affected-item__actions {
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-xs);
  }

  .stc-affected-item__applied-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #28A745;
    font-weight: 500;
  }

  .button--small {
    padding: 4px 12px;
    font-size: var(--font-size-xs);
  }

  /* ========== GENOME CASCADE SUGGESTIONS ========== */
  .stc-cascade {
    background: #FFF8E6;
    border: 2px solid #F0D58C;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
  }

  .stc-cascade__loading {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #8B6914;
  }

  .stc-cascade__header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
  }

  .stc-cascade__icon {
    font-size: var(--font-size-lg);
  }

  .stc-cascade__title {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    font-weight: 600;
    color: #8B6914;
  }

  .stc-cascade__summary {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary, #5C5346);
    margin: 0 0 var(--spacing-md) 0;
    line-height: 1.5;
  }

  .stc-cascade__list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
  }

  .stc-cascade__item {
    background: #fff;
    border: 1px solid #E8D9A8;
    border-radius: var(--radius-sm);
    padding: var(--spacing-md);
  }

  .stc-cascade__item-header {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: var(--spacing-sm);
  }

  .stc-cascade__item-header strong {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
  }

  .stc-cascade__item-reason {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #8B6914;
    font-style: italic;
  }

  .stc-cascade__item-suggestion {
    background: var(--color-background-secondary, #F5EEE6);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
  }

  .stc-cascade__item-label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-xs);
  }

  .stc-cascade__item-content {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.5;
  }

  .stc-cascade__item-content p {
    margin: 0;
  }

  .stc-cascade__item-actions {
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-xs);
  }

  .stc-cascade__bulk-actions {
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-sm);
    padding-top: var(--spacing-sm);
    border-top: 1px solid #E8D9A8;
  }

  .stc-cascade__success {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #28A745;
  }

  .stc-cascade__success-icon {
    font-size: var(--font-size-lg);
  }

  .stc-cascade__error {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: #DC3545;
  }

  /* ========== CHARACTERS SECTION ========== */
  .stc-characters {
    margin-top: var(--spacing-xxl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-characters__heading {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.5rem;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-sm);
  }

  .stc-characters__coach {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    background: var(--color-background-secondary, #FAF7F2);
    padding: var(--spacing-md);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-xl);
    line-height: 1.5;
  }

  /* Pyramid Layout */
  .stc-characters__pyramid {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-lg);
  }

  .stc-characters__tier {
    display: flex;
    justify-content: center;
    gap: var(--spacing-md);
    flex-wrap: wrap;
  }

  .stc-characters__tier--1 {
    /* Tier 1: Drivers - 2 cards centered */
    padding-bottom: var(--spacing-lg);
    margin-bottom: var(--spacing-lg);
    border-bottom: 1px solid var(--color-border-default, #D9CFC2);
    position: relative;
  }

  .stc-characters__tier--1::after {
    content: 'Drivers';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--color-background-secondary, #F5F0E8);
    padding: 0 var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-characters__tier--2 {
    /* Tier 2: Supports - 4 cards in a row */
    position: relative;
    padding-top: var(--spacing-md);
  }

  .stc-characters__tier--2::before {
    content: 'Supports';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--color-background-secondary, #F5F0E8);
    padding: 0 var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-characters__tier--2 .stc-character-slot {
    width: 200px;
    min-height: 160px;
  }

  /* Character Slot */
  .stc-character-slot {
    width: 280px;
    min-height: 180px;
    border: 2px dashed var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    background: var(--color-background-card, #FFFCF8);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .stc-character-slot:hover {
    border-color: var(--color-accent-primary, #B85C38);
  }

  .stc-character-slot--filled {
    border-style: solid;
    border-color: var(--color-border-default, #D9CFC2);
  }

  /* Empty Slot */
  .stc-character-slot__empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    text-align: center;
    min-height: 150px;
  }

  .stc-character-slot__role {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    font-weight: 600;
    color: var(--color-accent-primary, #B85C38);
    margin-bottom: var(--spacing-xs);
  }

  .stc-character-slot__desc {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    line-height: 1.4;
    margin-bottom: var(--spacing-md);
  }

  .stc-character-slot__add {
    font-size: var(--font-size-xs);
    padding: var(--spacing-xs) var(--spacing-sm);
  }

  /* Filled Slot - Character Card */
  .stc-character-card {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .stc-character-card__name {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
  }

  .stc-character-card__role-badge {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    padding: 2px 8px;
    border-radius: 12px;
    background: var(--color-accent-primary, #B85C38);
    color: white;
  }

  .stc-character-card__field {
    margin-bottom: var(--spacing-xs);
  }

  .stc-character-card__label {
    font-family: 'Source Sans 3', sans-serif;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-character-card__value {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.4;
  }

  .stc-character-card__value--empty {
    font-style: italic;
    color: var(--color-text-muted, #8B7D6B);
  }

  .stc-character-card__actions {
    display: flex;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-sm);
    padding-top: var(--spacing-sm);
    border-top: 1px solid var(--color-border-light, #E8E0D5);
  }

  .stc-character-card__view,
  .stc-character-card__edit {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: none;
    border: 1px solid var(--color-border-default, #D9CFC2);
    padding: 4px 10px;
    cursor: pointer;
    color: var(--color-text-muted, #8B7D6B);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    font-weight: 500;
    transition: all 0.2s ease;
    border-radius: 4px;
  }

  .stc-character-card__view:hover,
  .stc-character-card__edit:hover {
    color: var(--color-accent-primary, #B85C38);
    border-color: var(--color-accent-primary, #B85C38);
    background: rgba(184, 92, 56, 0.05);
  }

  .stc-character-card__want,
  .stc-character-card__need {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-secondary, #5C4D3C);
    line-height: 1.4;
    margin-bottom: var(--spacing-xs);
  }

  .stc-character-card__want strong,
  .stc-character-card__need strong {
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
  }

  .stc-character-card__arc {
    display: inline-block;
    font-family: 'Source Sans 3', sans-serif;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    padding: 2px 8px;
    border-radius: 12px;
    background: var(--color-background-tertiary, #EDE4D9);
    color: var(--color-text-secondary, #5C4D3C);
    margin-top: auto;
  }

  .stc-character-card__actions {
    display: flex;
    gap: var(--spacing-xs);
    margin-top: auto;
    padding-top: var(--spacing-sm);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-character-card__btn {
    flex: 1;
    font-size: var(--font-size-xs);
    padding: var(--spacing-xs);
  }

  /* Extra Characters Section */
  .stc-characters__extra {
    margin-top: var(--spacing-xl);
    padding-top: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-characters__extra-title {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-muted, #8B7D6B);
    margin-bottom: var(--spacing-md);
  }

  .stc-characters__extra-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-md);
  }

  .stc-characters__add-more {
    margin-top: var(--spacing-lg);
    text-align: center;
  }

  /* Modal */
  .stc-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .stc-modal__backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
  }

  .stc-modal__content {
    position: relative;
    background: white;
    border-radius: var(--radius-lg);
    padding: var(--spacing-xl);
    max-width: 700px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  }

  .stc-modal__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-lg);
  }

  .stc-modal__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.25rem;
    color: var(--color-text-primary, #2C2416);
    margin: 0;
  }

  .stc-modal__close {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--color-text-muted, #8B7D6B);
    cursor: pointer;
    padding: 0;
    line-height: 1;
  }

  .stc-modal__close:hover {
    color: var(--color-text-primary, #2C2416);
  }

  /* Character Sheet (read-only view) */
  .stc-character-sheet {
    max-width: 550px;
  }

  .stc-character-sheet__content {
    margin-top: var(--spacing-md);
  }

  .stc-character-sheet__role {
    display: inline-block;
    background: rgba(184, 92, 56, 0.15);
    color: var(--color-accent-primary, #B85C38);
    padding: 4px 12px;
    border-radius: 12px;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--spacing-md);
  }

  .stc-character-sheet__section {
    margin-bottom: var(--spacing-lg);
  }

  .stc-character-sheet__label {
    font-family: 'Lora', Georgia, serif;
    font-size: var(--font-size-xs);
    font-weight: 600;
    color: var(--color-text-muted, #8B7D6B);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin: 0 0 var(--spacing-xs) 0;
  }

  .stc-character-sheet__value {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    color: var(--color-text-primary, #2C2416);
    line-height: 1.6;
    margin: 0;
  }

  .stc-character-sheet__arc-type {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-accent-primary, #B85C38);
    margin: 0 0 var(--spacing-xs) 0;
  }

  .stc-character-sheet__actions {
    display: flex;
    justify-content: flex-end;
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  /* Character Form */
  .stc-character-form {
    position: relative;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--spacing-md) var(--spacing-lg);
  }

  .stc-character-form__loading {
    grid-column: 1 / -1;
  }

  .stc-character-form__field {
    margin-bottom: 0;
  }

  /* Full width fields */
  .stc-character-form__field[data-field="arc_description"],
  .stc-character-form__field[data-field="connections"] {
    grid-column: 1 / -1;
  }

  .stc-character-form__actions {
    grid-column: 1 / -1;
  }

  .stc-character-form__delete {
    grid-column: 1 / -1;
  }

  @media (max-width: 600px) {
    .stc-character-form {
      grid-template-columns: 1fr;
    }
  }

  .stc-character-form__field label {
    display: block;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
    margin-bottom: var(--spacing-xs);
  }

  .stc-character-form__field input,
  .stc-character-form__field textarea,
  .stc-character-form__field select {
    width: 100%;
    padding: var(--spacing-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-sm);
    background: white;
  }

  .stc-character-form__field input:focus,
  .stc-character-form__field textarea:focus,
  .stc-character-form__field select:focus {
    outline: none;
    border-color: var(--color-accent-primary, #B85C38);
    box-shadow: 0 0 0 2px rgba(184, 92, 56, 0.2);
  }

  .stc-character-form__actions {
    display: flex;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-lg);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  .stc-character-form__actions .button {
    flex: 1;
  }

  .stc-character-form__delete {
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
    text-align: center;
  }

  .button--danger {
    background: #DC3545;
    color: white;
    border-color: #DC3545;
  }

  .button--danger:hover {
    background: #c82333;
    border-color: #c82333;
  }

  /* Character Form Loading State */
  .stc-character-form__loading {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 252, 248, 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-md);
    z-index: 10;
    border-radius: var(--radius-md);
  }

  .stc-character-form__loading span {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary, #5C4D3C);
  }

  .stc-character-form__label-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-xs);
  }

  .stc-character-form__label-row label {
    margin-bottom: 0;
  }

  .stc-character-form__reroll {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: var(--color-text-muted, #8B7D6B);
    border-radius: 4px;
    transition: all 0.2s ease;
    opacity: 0.6;
  }

  .stc-character-form__reroll:hover {
    opacity: 1;
    color: var(--color-accent-primary, #B85C38);
    background: rgba(184, 92, 56, 0.1);
  }

  .stc-character-form__reroll:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  .stc-character-form__reroll--loading {
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .stc-character-form__field--loading input,
  .stc-character-form__field--loading textarea,
  .stc-character-form__field--loading select {
    background: var(--color-background-tertiary, #EDE4D9);
    color: var(--color-text-muted, #8B7D6B);
  }

  /* Cascade Modal */
  .stc-cascade-modal__content {
    max-width: 600px;
  }

  .stc-cascade-modal__intro {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary, #5C4D3C);
    margin-bottom: var(--spacing-lg);
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--color-background-secondary, #FAF7F2);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--color-accent-primary, #B85C38);
  }

  .stc-cascade-modal__items {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: var(--spacing-lg);
  }

  .stc-cascade-item {
    border: 1px solid var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    background: var(--color-background-card, #FFFCF8);
  }

  .stc-cascade-item:last-child {
    margin-bottom: 0;
  }

  .stc-cascade-item__header {
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
  }

  .stc-cascade-item__checkbox {
    margin-top: 2px;
    width: 18px;
    height: 18px;
    accent-color: var(--color-accent-primary, #B85C38);
  }

  .stc-cascade-item__title {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-primary, #2C2416);
  }

  .stc-cascade-item__target {
    color: var(--color-accent-primary, #B85C38);
  }

  .stc-cascade-item__reason {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    font-style: italic;
    margin-bottom: var(--spacing-sm);
    padding-left: 26px;
  }

  .stc-cascade-item__diff {
    padding-left: 26px;
  }

  .stc-cascade-item__old,
  .stc-cascade-item__new {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-xs);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    margin-bottom: var(--spacing-xs);
  }

  .stc-cascade-item__old {
    background: #fce8e8;
    color: #8b2525;
    text-decoration: line-through;
  }

  .stc-cascade-item__new {
    background: #e8f5e8;
    color: #256b25;
  }

  .stc-cascade-modal__actions {
    display: flex;
    gap: var(--spacing-sm);
    justify-content: flex-end;
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--color-border-default, #D9CFC2);
  }

  /* Responsive */
  @media (max-width: 900px) {
    .stc-characters__tier--2 .stc-character-slot {
      width: 170px;
      min-height: 140px;
    }
  }

  @media (max-width: 800px) {
    .stc-characters__tier--2 {
      flex-wrap: wrap;
    }

    .stc-characters__tier--2 .stc-character-slot {
      width: calc(50% - var(--spacing-sm));
    }
  }

  @media (max-width: 640px) {
    .stc-character-slot {
      width: 100%;
    }

    .stc-characters__tier {
      flex-direction: column;
      align-items: center;
    }

    .stc-characters__tier--2 .stc-character-slot {
      width: 100%;
    }
  }

  /* Dev Zone */
  .stc-dev-zone {
    margin-top: var(--spacing-xl);
    border: 2px dashed var(--color-border-default, #D9CFC2);
    border-radius: var(--radius-md);
    background: rgba(139, 125, 107, 0.05);
  }

  .stc-dev-zone__header {
    padding: 0;
  }

  .stc-dev-zone__toggle {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) var(--spacing-md);
    background: none;
    border: none;
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-muted, #8B7D6B);
    cursor: pointer;
    transition: color 0.2s ease;
  }

  .stc-dev-zone__toggle:hover {
    color: var(--color-text-secondary, #5C4D3C);
  }

  .stc-dev-zone__arrow {
    font-size: 10px;
  }

  .stc-dev-zone__content {
    padding: var(--spacing-md);
    border-top: 1px dashed var(--color-border-default, #D9CFC2);
  }

  .stc-dev-zone__content h4 {
    font-family: 'Lora', Georgia, serif;
    font-size: var(--font-size-sm);
    font-weight: 600;
    color: var(--color-text-secondary, #5C4D3C);
    margin: 0 0 var(--spacing-sm) 0;
  }

  .stc-dev-zone__label {
    font-size: var(--font-size-xs);
    color: var(--color-text-muted, #8B7D6B);
    margin: 0 0 var(--spacing-xs) 0;
  }

  .stc-dev-zone__output {
    background: white;
    padding: var(--spacing-md);
    border-radius: var(--radius-sm);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    line-height: 1.6;
    color: var(--color-text-primary, #2C2416);
  }

  .stc-dev-zone__output em {
    color: var(--color-text-muted, #8B7D6B);
  }

  /* Toast notifications */
  .stc-toast-container {
    position: fixed;
    top: var(--spacing-lg);
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--spacing-sm);
    pointer-events: none;
  }

  .stc-toast {
    background: var(--color-text-primary, #2C2416);
    color: white;
    padding: var(--spacing-md) var(--spacing-lg);
    border-radius: var(--radius-md);
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
    animation: toastSlideDown 0.3s ease-out;
    pointer-events: auto;
    max-width: 400px;
  }

  .stc-toast--checking {
    background: linear-gradient(135deg, #4A5568 0%, #2D3748 100%);
  }

  .stc-toast--success {
    background: linear-gradient(135deg, #48BB78 0%, #38A169 100%);
  }

  .stc-toast--info {
    background: linear-gradient(135deg, #4299E1 0%, #3182CE 100%);
  }

  .stc-toast__spinner {
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    flex-shrink: 0;
  }

  .stc-toast__icon {
    flex-shrink: 0;
  }

  @keyframes toastSlideDown {
    from {
      opacity: 0;
      transform: translateY(-100%);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes toastSlideOut {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-100%);
    }
  }

  .stc-toast--exiting {
    animation: toastSlideOut 0.3s ease-in forwards;
  }

  /* AI Loading Overlay */
  .stc-ai-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 20000;
    background: rgba(44, 36, 22, 0.85);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: overlayFadeIn 0.3s ease-out;
  }

  @keyframes overlayFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .stc-ai-overlay__content {
    text-align: center;
    color: #FAF6F1;
    max-width: 320px;
    padding: var(--spacing-xl);
  }

  .stc-ai-overlay__icon {
    margin-bottom: var(--spacing-lg);
    color: var(--color-accent-primary, #B85C38);
    animation: iconSpin 2s linear infinite;
  }

  @keyframes iconSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .stc-ai-overlay__title {
    font-family: 'Lora', Georgia, serif;
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0 0 var(--spacing-sm) 0;
    color: #FAF6F1;
  }

  .stc-ai-overlay__message {
    font-family: 'Source Sans 3', sans-serif;
    font-size: var(--font-size-base);
    color: rgba(250, 246, 241, 0.7);
    margin: 0 0 var(--spacing-lg) 0;
  }

  .stc-ai-overlay__dots {
    display: flex;
    justify-content: center;
    gap: 8px;
  }

  .stc-ai-overlay__dots span {
    width: 10px;
    height: 10px;
    background: var(--color-accent-primary, #B85C38);
    border-radius: 50%;
    animation: dotBounce 1.4s ease-in-out infinite;
  }

  .stc-ai-overlay__dots span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .stc-ai-overlay__dots span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes dotBounce {
    0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
  }
</style>
